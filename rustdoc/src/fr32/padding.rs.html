<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/fr32-11.1.0/src/padding.rs`."><title>padding.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="fr32" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.0 (051478957 2024-07-21)" data-channel="1.80.0" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../../static.files/src-script-e66d777a5a92e9b2.js"></script><script defer src="../../src-files.js"></script><script defer src="../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers"><a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
<a href="#3" id="3">3</a>
<a href="#4" id="4">4</a>
<a href="#5" id="5">5</a>
<a href="#6" id="6">6</a>
<a href="#7" id="7">7</a>
<a href="#8" id="8">8</a>
<a href="#9" id="9">9</a>
<a href="#10" id="10">10</a>
<a href="#11" id="11">11</a>
<a href="#12" id="12">12</a>
<a href="#13" id="13">13</a>
<a href="#14" id="14">14</a>
<a href="#15" id="15">15</a>
<a href="#16" id="16">16</a>
<a href="#17" id="17">17</a>
<a href="#18" id="18">18</a>
<a href="#19" id="19">19</a>
<a href="#20" id="20">20</a>
<a href="#21" id="21">21</a>
<a href="#22" id="22">22</a>
<a href="#23" id="23">23</a>
<a href="#24" id="24">24</a>
<a href="#25" id="25">25</a>
<a href="#26" id="26">26</a>
<a href="#27" id="27">27</a>
<a href="#28" id="28">28</a>
<a href="#29" id="29">29</a>
<a href="#30" id="30">30</a>
<a href="#31" id="31">31</a>
<a href="#32" id="32">32</a>
<a href="#33" id="33">33</a>
<a href="#34" id="34">34</a>
<a href="#35" id="35">35</a>
<a href="#36" id="36">36</a>
<a href="#37" id="37">37</a>
<a href="#38" id="38">38</a>
<a href="#39" id="39">39</a>
<a href="#40" id="40">40</a>
<a href="#41" id="41">41</a>
<a href="#42" id="42">42</a>
<a href="#43" id="43">43</a>
<a href="#44" id="44">44</a>
<a href="#45" id="45">45</a>
<a href="#46" id="46">46</a>
<a href="#47" id="47">47</a>
<a href="#48" id="48">48</a>
<a href="#49" id="49">49</a>
<a href="#50" id="50">50</a>
<a href="#51" id="51">51</a>
<a href="#52" id="52">52</a>
<a href="#53" id="53">53</a>
<a href="#54" id="54">54</a>
<a href="#55" id="55">55</a>
<a href="#56" id="56">56</a>
<a href="#57" id="57">57</a>
<a href="#58" id="58">58</a>
<a href="#59" id="59">59</a>
<a href="#60" id="60">60</a>
<a href="#61" id="61">61</a>
<a href="#62" id="62">62</a>
<a href="#63" id="63">63</a>
<a href="#64" id="64">64</a>
<a href="#65" id="65">65</a>
<a href="#66" id="66">66</a>
<a href="#67" id="67">67</a>
<a href="#68" id="68">68</a>
<a href="#69" id="69">69</a>
<a href="#70" id="70">70</a>
<a href="#71" id="71">71</a>
<a href="#72" id="72">72</a>
<a href="#73" id="73">73</a>
<a href="#74" id="74">74</a>
<a href="#75" id="75">75</a>
<a href="#76" id="76">76</a>
<a href="#77" id="77">77</a>
<a href="#78" id="78">78</a>
<a href="#79" id="79">79</a>
<a href="#80" id="80">80</a>
<a href="#81" id="81">81</a>
<a href="#82" id="82">82</a>
<a href="#83" id="83">83</a>
<a href="#84" id="84">84</a>
<a href="#85" id="85">85</a>
<a href="#86" id="86">86</a>
<a href="#87" id="87">87</a>
<a href="#88" id="88">88</a>
<a href="#89" id="89">89</a>
<a href="#90" id="90">90</a>
<a href="#91" id="91">91</a>
<a href="#92" id="92">92</a>
<a href="#93" id="93">93</a>
<a href="#94" id="94">94</a>
<a href="#95" id="95">95</a>
<a href="#96" id="96">96</a>
<a href="#97" id="97">97</a>
<a href="#98" id="98">98</a>
<a href="#99" id="99">99</a>
<a href="#100" id="100">100</a>
<a href="#101" id="101">101</a>
<a href="#102" id="102">102</a>
<a href="#103" id="103">103</a>
<a href="#104" id="104">104</a>
<a href="#105" id="105">105</a>
<a href="#106" id="106">106</a>
<a href="#107" id="107">107</a>
<a href="#108" id="108">108</a>
<a href="#109" id="109">109</a>
<a href="#110" id="110">110</a>
<a href="#111" id="111">111</a>
<a href="#112" id="112">112</a>
<a href="#113" id="113">113</a>
<a href="#114" id="114">114</a>
<a href="#115" id="115">115</a>
<a href="#116" id="116">116</a>
<a href="#117" id="117">117</a>
<a href="#118" id="118">118</a>
<a href="#119" id="119">119</a>
<a href="#120" id="120">120</a>
<a href="#121" id="121">121</a>
<a href="#122" id="122">122</a>
<a href="#123" id="123">123</a>
<a href="#124" id="124">124</a>
<a href="#125" id="125">125</a>
<a href="#126" id="126">126</a>
<a href="#127" id="127">127</a>
<a href="#128" id="128">128</a>
<a href="#129" id="129">129</a>
<a href="#130" id="130">130</a>
<a href="#131" id="131">131</a>
<a href="#132" id="132">132</a>
<a href="#133" id="133">133</a>
<a href="#134" id="134">134</a>
<a href="#135" id="135">135</a>
<a href="#136" id="136">136</a>
<a href="#137" id="137">137</a>
<a href="#138" id="138">138</a>
<a href="#139" id="139">139</a>
<a href="#140" id="140">140</a>
<a href="#141" id="141">141</a>
<a href="#142" id="142">142</a>
<a href="#143" id="143">143</a>
<a href="#144" id="144">144</a>
<a href="#145" id="145">145</a>
<a href="#146" id="146">146</a>
<a href="#147" id="147">147</a>
<a href="#148" id="148">148</a>
<a href="#149" id="149">149</a>
<a href="#150" id="150">150</a>
<a href="#151" id="151">151</a>
<a href="#152" id="152">152</a>
<a href="#153" id="153">153</a>
<a href="#154" id="154">154</a>
<a href="#155" id="155">155</a>
<a href="#156" id="156">156</a>
<a href="#157" id="157">157</a>
<a href="#158" id="158">158</a>
<a href="#159" id="159">159</a>
<a href="#160" id="160">160</a>
<a href="#161" id="161">161</a>
<a href="#162" id="162">162</a>
<a href="#163" id="163">163</a>
<a href="#164" id="164">164</a>
<a href="#165" id="165">165</a>
<a href="#166" id="166">166</a>
<a href="#167" id="167">167</a>
<a href="#168" id="168">168</a>
<a href="#169" id="169">169</a>
<a href="#170" id="170">170</a>
<a href="#171" id="171">171</a>
<a href="#172" id="172">172</a>
<a href="#173" id="173">173</a>
<a href="#174" id="174">174</a>
<a href="#175" id="175">175</a>
<a href="#176" id="176">176</a>
<a href="#177" id="177">177</a>
<a href="#178" id="178">178</a>
<a href="#179" id="179">179</a>
<a href="#180" id="180">180</a>
<a href="#181" id="181">181</a>
<a href="#182" id="182">182</a>
<a href="#183" id="183">183</a>
<a href="#184" id="184">184</a>
<a href="#185" id="185">185</a>
<a href="#186" id="186">186</a>
<a href="#187" id="187">187</a>
<a href="#188" id="188">188</a>
<a href="#189" id="189">189</a>
<a href="#190" id="190">190</a>
<a href="#191" id="191">191</a>
<a href="#192" id="192">192</a>
<a href="#193" id="193">193</a>
<a href="#194" id="194">194</a>
<a href="#195" id="195">195</a>
<a href="#196" id="196">196</a>
<a href="#197" id="197">197</a>
<a href="#198" id="198">198</a>
<a href="#199" id="199">199</a>
<a href="#200" id="200">200</a>
<a href="#201" id="201">201</a>
<a href="#202" id="202">202</a>
<a href="#203" id="203">203</a>
<a href="#204" id="204">204</a>
<a href="#205" id="205">205</a>
<a href="#206" id="206">206</a>
<a href="#207" id="207">207</a>
<a href="#208" id="208">208</a>
<a href="#209" id="209">209</a>
<a href="#210" id="210">210</a>
<a href="#211" id="211">211</a>
<a href="#212" id="212">212</a>
<a href="#213" id="213">213</a>
<a href="#214" id="214">214</a>
<a href="#215" id="215">215</a>
<a href="#216" id="216">216</a>
<a href="#217" id="217">217</a>
<a href="#218" id="218">218</a>
<a href="#219" id="219">219</a>
<a href="#220" id="220">220</a>
<a href="#221" id="221">221</a>
<a href="#222" id="222">222</a>
<a href="#223" id="223">223</a>
<a href="#224" id="224">224</a>
<a href="#225" id="225">225</a>
<a href="#226" id="226">226</a>
<a href="#227" id="227">227</a>
<a href="#228" id="228">228</a>
<a href="#229" id="229">229</a>
<a href="#230" id="230">230</a>
<a href="#231" id="231">231</a>
<a href="#232" id="232">232</a>
<a href="#233" id="233">233</a>
<a href="#234" id="234">234</a>
<a href="#235" id="235">235</a>
<a href="#236" id="236">236</a>
<a href="#237" id="237">237</a>
<a href="#238" id="238">238</a>
<a href="#239" id="239">239</a>
<a href="#240" id="240">240</a>
<a href="#241" id="241">241</a>
<a href="#242" id="242">242</a>
<a href="#243" id="243">243</a>
<a href="#244" id="244">244</a>
<a href="#245" id="245">245</a>
<a href="#246" id="246">246</a>
<a href="#247" id="247">247</a>
<a href="#248" id="248">248</a>
<a href="#249" id="249">249</a>
<a href="#250" id="250">250</a>
<a href="#251" id="251">251</a>
<a href="#252" id="252">252</a>
<a href="#253" id="253">253</a>
<a href="#254" id="254">254</a>
<a href="#255" id="255">255</a>
<a href="#256" id="256">256</a>
<a href="#257" id="257">257</a>
<a href="#258" id="258">258</a>
<a href="#259" id="259">259</a>
<a href="#260" id="260">260</a>
<a href="#261" id="261">261</a>
<a href="#262" id="262">262</a>
<a href="#263" id="263">263</a>
<a href="#264" id="264">264</a>
<a href="#265" id="265">265</a>
<a href="#266" id="266">266</a>
<a href="#267" id="267">267</a>
<a href="#268" id="268">268</a>
<a href="#269" id="269">269</a>
<a href="#270" id="270">270</a>
<a href="#271" id="271">271</a>
<a href="#272" id="272">272</a>
<a href="#273" id="273">273</a>
<a href="#274" id="274">274</a>
<a href="#275" id="275">275</a>
<a href="#276" id="276">276</a>
<a href="#277" id="277">277</a>
<a href="#278" id="278">278</a>
<a href="#279" id="279">279</a>
<a href="#280" id="280">280</a>
<a href="#281" id="281">281</a>
<a href="#282" id="282">282</a>
<a href="#283" id="283">283</a>
<a href="#284" id="284">284</a>
<a href="#285" id="285">285</a>
<a href="#286" id="286">286</a>
<a href="#287" id="287">287</a>
<a href="#288" id="288">288</a>
<a href="#289" id="289">289</a>
<a href="#290" id="290">290</a>
<a href="#291" id="291">291</a>
<a href="#292" id="292">292</a>
<a href="#293" id="293">293</a>
<a href="#294" id="294">294</a>
<a href="#295" id="295">295</a>
<a href="#296" id="296">296</a>
<a href="#297" id="297">297</a>
<a href="#298" id="298">298</a>
<a href="#299" id="299">299</a>
<a href="#300" id="300">300</a>
<a href="#301" id="301">301</a>
<a href="#302" id="302">302</a>
<a href="#303" id="303">303</a>
<a href="#304" id="304">304</a>
<a href="#305" id="305">305</a>
<a href="#306" id="306">306</a>
<a href="#307" id="307">307</a>
<a href="#308" id="308">308</a>
<a href="#309" id="309">309</a>
<a href="#310" id="310">310</a>
<a href="#311" id="311">311</a>
<a href="#312" id="312">312</a>
<a href="#313" id="313">313</a>
<a href="#314" id="314">314</a>
<a href="#315" id="315">315</a>
<a href="#316" id="316">316</a>
<a href="#317" id="317">317</a>
<a href="#318" id="318">318</a>
<a href="#319" id="319">319</a>
<a href="#320" id="320">320</a>
<a href="#321" id="321">321</a>
<a href="#322" id="322">322</a>
<a href="#323" id="323">323</a>
<a href="#324" id="324">324</a>
<a href="#325" id="325">325</a>
<a href="#326" id="326">326</a>
<a href="#327" id="327">327</a>
<a href="#328" id="328">328</a>
<a href="#329" id="329">329</a>
<a href="#330" id="330">330</a>
<a href="#331" id="331">331</a>
<a href="#332" id="332">332</a>
<a href="#333" id="333">333</a>
<a href="#334" id="334">334</a>
<a href="#335" id="335">335</a>
<a href="#336" id="336">336</a>
<a href="#337" id="337">337</a>
<a href="#338" id="338">338</a>
<a href="#339" id="339">339</a>
<a href="#340" id="340">340</a>
<a href="#341" id="341">341</a>
<a href="#342" id="342">342</a>
<a href="#343" id="343">343</a>
<a href="#344" id="344">344</a>
<a href="#345" id="345">345</a>
<a href="#346" id="346">346</a>
<a href="#347" id="347">347</a>
<a href="#348" id="348">348</a>
<a href="#349" id="349">349</a>
<a href="#350" id="350">350</a>
<a href="#351" id="351">351</a>
<a href="#352" id="352">352</a>
<a href="#353" id="353">353</a>
<a href="#354" id="354">354</a>
<a href="#355" id="355">355</a>
<a href="#356" id="356">356</a>
<a href="#357" id="357">357</a>
<a href="#358" id="358">358</a>
<a href="#359" id="359">359</a>
<a href="#360" id="360">360</a>
<a href="#361" id="361">361</a>
<a href="#362" id="362">362</a>
<a href="#363" id="363">363</a>
<a href="#364" id="364">364</a>
<a href="#365" id="365">365</a>
<a href="#366" id="366">366</a>
<a href="#367" id="367">367</a>
<a href="#368" id="368">368</a>
<a href="#369" id="369">369</a>
<a href="#370" id="370">370</a>
<a href="#371" id="371">371</a>
<a href="#372" id="372">372</a>
<a href="#373" id="373">373</a>
<a href="#374" id="374">374</a>
<a href="#375" id="375">375</a>
<a href="#376" id="376">376</a>
<a href="#377" id="377">377</a>
<a href="#378" id="378">378</a>
<a href="#379" id="379">379</a>
<a href="#380" id="380">380</a>
<a href="#381" id="381">381</a>
<a href="#382" id="382">382</a>
<a href="#383" id="383">383</a>
<a href="#384" id="384">384</a>
<a href="#385" id="385">385</a>
<a href="#386" id="386">386</a>
<a href="#387" id="387">387</a>
<a href="#388" id="388">388</a>
<a href="#389" id="389">389</a>
<a href="#390" id="390">390</a>
<a href="#391" id="391">391</a>
<a href="#392" id="392">392</a>
<a href="#393" id="393">393</a>
<a href="#394" id="394">394</a>
<a href="#395" id="395">395</a>
<a href="#396" id="396">396</a>
<a href="#397" id="397">397</a>
<a href="#398" id="398">398</a>
<a href="#399" id="399">399</a>
<a href="#400" id="400">400</a>
<a href="#401" id="401">401</a>
<a href="#402" id="402">402</a>
<a href="#403" id="403">403</a>
<a href="#404" id="404">404</a>
<a href="#405" id="405">405</a>
<a href="#406" id="406">406</a>
<a href="#407" id="407">407</a>
<a href="#408" id="408">408</a>
<a href="#409" id="409">409</a>
<a href="#410" id="410">410</a>
<a href="#411" id="411">411</a>
<a href="#412" id="412">412</a>
<a href="#413" id="413">413</a>
<a href="#414" id="414">414</a>
<a href="#415" id="415">415</a>
<a href="#416" id="416">416</a>
<a href="#417" id="417">417</a>
<a href="#418" id="418">418</a>
<a href="#419" id="419">419</a>
<a href="#420" id="420">420</a>
<a href="#421" id="421">421</a>
<a href="#422" id="422">422</a>
<a href="#423" id="423">423</a>
<a href="#424" id="424">424</a>
<a href="#425" id="425">425</a>
<a href="#426" id="426">426</a>
<a href="#427" id="427">427</a>
<a href="#428" id="428">428</a>
<a href="#429" id="429">429</a>
<a href="#430" id="430">430</a>
<a href="#431" id="431">431</a>
<a href="#432" id="432">432</a>
<a href="#433" id="433">433</a>
<a href="#434" id="434">434</a>
<a href="#435" id="435">435</a>
<a href="#436" id="436">436</a>
<a href="#437" id="437">437</a>
<a href="#438" id="438">438</a>
<a href="#439" id="439">439</a>
<a href="#440" id="440">440</a>
<a href="#441" id="441">441</a>
<a href="#442" id="442">442</a>
<a href="#443" id="443">443</a>
<a href="#444" id="444">444</a>
<a href="#445" id="445">445</a>
<a href="#446" id="446">446</a>
<a href="#447" id="447">447</a>
<a href="#448" id="448">448</a>
<a href="#449" id="449">449</a>
<a href="#450" id="450">450</a>
<a href="#451" id="451">451</a>
<a href="#452" id="452">452</a>
<a href="#453" id="453">453</a>
<a href="#454" id="454">454</a>
<a href="#455" id="455">455</a>
<a href="#456" id="456">456</a>
<a href="#457" id="457">457</a>
<a href="#458" id="458">458</a>
<a href="#459" id="459">459</a>
<a href="#460" id="460">460</a>
<a href="#461" id="461">461</a>
<a href="#462" id="462">462</a>
<a href="#463" id="463">463</a>
<a href="#464" id="464">464</a>
<a href="#465" id="465">465</a>
<a href="#466" id="466">466</a>
<a href="#467" id="467">467</a>
<a href="#468" id="468">468</a>
<a href="#469" id="469">469</a>
<a href="#470" id="470">470</a>
<a href="#471" id="471">471</a>
<a href="#472" id="472">472</a>
<a href="#473" id="473">473</a>
<a href="#474" id="474">474</a>
<a href="#475" id="475">475</a>
<a href="#476" id="476">476</a>
<a href="#477" id="477">477</a>
<a href="#478" id="478">478</a>
<a href="#479" id="479">479</a>
<a href="#480" id="480">480</a>
<a href="#481" id="481">481</a>
<a href="#482" id="482">482</a>
<a href="#483" id="483">483</a>
<a href="#484" id="484">484</a>
<a href="#485" id="485">485</a>
<a href="#486" id="486">486</a>
<a href="#487" id="487">487</a>
<a href="#488" id="488">488</a>
<a href="#489" id="489">489</a>
<a href="#490" id="490">490</a>
<a href="#491" id="491">491</a>
<a href="#492" id="492">492</a>
<a href="#493" id="493">493</a>
<a href="#494" id="494">494</a>
<a href="#495" id="495">495</a>
<a href="#496" id="496">496</a>
<a href="#497" id="497">497</a>
<a href="#498" id="498">498</a>
<a href="#499" id="499">499</a>
<a href="#500" id="500">500</a>
<a href="#501" id="501">501</a>
<a href="#502" id="502">502</a>
<a href="#503" id="503">503</a>
<a href="#504" id="504">504</a>
<a href="#505" id="505">505</a>
<a href="#506" id="506">506</a>
<a href="#507" id="507">507</a>
<a href="#508" id="508">508</a>
<a href="#509" id="509">509</a>
<a href="#510" id="510">510</a>
<a href="#511" id="511">511</a>
<a href="#512" id="512">512</a>
<a href="#513" id="513">513</a>
<a href="#514" id="514">514</a>
<a href="#515" id="515">515</a>
<a href="#516" id="516">516</a>
<a href="#517" id="517">517</a>
<a href="#518" id="518">518</a>
<a href="#519" id="519">519</a>
<a href="#520" id="520">520</a>
<a href="#521" id="521">521</a>
<a href="#522" id="522">522</a>
<a href="#523" id="523">523</a>
<a href="#524" id="524">524</a>
<a href="#525" id="525">525</a>
<a href="#526" id="526">526</a>
<a href="#527" id="527">527</a>
<a href="#528" id="528">528</a>
<a href="#529" id="529">529</a>
<a href="#530" id="530">530</a>
<a href="#531" id="531">531</a>
<a href="#532" id="532">532</a>
<a href="#533" id="533">533</a>
<a href="#534" id="534">534</a>
<a href="#535" id="535">535</a>
<a href="#536" id="536">536</a>
<a href="#537" id="537">537</a>
<a href="#538" id="538">538</a>
<a href="#539" id="539">539</a>
<a href="#540" id="540">540</a>
<a href="#541" id="541">541</a>
<a href="#542" id="542">542</a>
<a href="#543" id="543">543</a>
<a href="#544" id="544">544</a>
<a href="#545" id="545">545</a>
<a href="#546" id="546">546</a>
<a href="#547" id="547">547</a>
<a href="#548" id="548">548</a>
<a href="#549" id="549">549</a>
<a href="#550" id="550">550</a>
<a href="#551" id="551">551</a>
<a href="#552" id="552">552</a>
<a href="#553" id="553">553</a>
<a href="#554" id="554">554</a>
<a href="#555" id="555">555</a>
<a href="#556" id="556">556</a>
<a href="#557" id="557">557</a>
<a href="#558" id="558">558</a>
<a href="#559" id="559">559</a>
<a href="#560" id="560">560</a>
<a href="#561" id="561">561</a>
<a href="#562" id="562">562</a>
<a href="#563" id="563">563</a>
<a href="#564" id="564">564</a>
<a href="#565" id="565">565</a>
<a href="#566" id="566">566</a>
<a href="#567" id="567">567</a>
<a href="#568" id="568">568</a>
<a href="#569" id="569">569</a>
<a href="#570" id="570">570</a>
<a href="#571" id="571">571</a>
<a href="#572" id="572">572</a>
<a href="#573" id="573">573</a>
<a href="#574" id="574">574</a>
<a href="#575" id="575">575</a>
<a href="#576" id="576">576</a>
<a href="#577" id="577">577</a>
<a href="#578" id="578">578</a>
<a href="#579" id="579">579</a>
<a href="#580" id="580">580</a>
<a href="#581" id="581">581</a>
<a href="#582" id="582">582</a>
<a href="#583" id="583">583</a>
<a href="#584" id="584">584</a>
<a href="#585" id="585">585</a>
<a href="#586" id="586">586</a>
<a href="#587" id="587">587</a>
<a href="#588" id="588">588</a>
<a href="#589" id="589">589</a>
<a href="#590" id="590">590</a>
<a href="#591" id="591">591</a>
<a href="#592" id="592">592</a>
<a href="#593" id="593">593</a>
<a href="#594" id="594">594</a>
<a href="#595" id="595">595</a>
<a href="#596" id="596">596</a>
<a href="#597" id="597">597</a>
<a href="#598" id="598">598</a>
<a href="#599" id="599">599</a>
<a href="#600" id="600">600</a>
<a href="#601" id="601">601</a>
<a href="#602" id="602">602</a>
<a href="#603" id="603">603</a>
<a href="#604" id="604">604</a>
<a href="#605" id="605">605</a>
<a href="#606" id="606">606</a>
<a href="#607" id="607">607</a>
<a href="#608" id="608">608</a>
<a href="#609" id="609">609</a>
<a href="#610" id="610">610</a>
<a href="#611" id="611">611</a>
<a href="#612" id="612">612</a>
<a href="#613" id="613">613</a>
<a href="#614" id="614">614</a>
<a href="#615" id="615">615</a>
<a href="#616" id="616">616</a>
<a href="#617" id="617">617</a>
<a href="#618" id="618">618</a>
<a href="#619" id="619">619</a>
<a href="#620" id="620">620</a>
<a href="#621" id="621">621</a>
<a href="#622" id="622">622</a>
<a href="#623" id="623">623</a>
<a href="#624" id="624">624</a>
<a href="#625" id="625">625</a>
<a href="#626" id="626">626</a>
<a href="#627" id="627">627</a>
<a href="#628" id="628">628</a>
<a href="#629" id="629">629</a>
<a href="#630" id="630">630</a>
<a href="#631" id="631">631</a>
<a href="#632" id="632">632</a>
<a href="#633" id="633">633</a>
<a href="#634" id="634">634</a>
<a href="#635" id="635">635</a>
<a href="#636" id="636">636</a>
<a href="#637" id="637">637</a>
<a href="#638" id="638">638</a>
<a href="#639" id="639">639</a>
<a href="#640" id="640">640</a>
<a href="#641" id="641">641</a>
<a href="#642" id="642">642</a>
<a href="#643" id="643">643</a>
<a href="#644" id="644">644</a>
<a href="#645" id="645">645</a>
<a href="#646" id="646">646</a>
<a href="#647" id="647">647</a>
<a href="#648" id="648">648</a>
<a href="#649" id="649">649</a>
<a href="#650" id="650">650</a>
<a href="#651" id="651">651</a>
<a href="#652" id="652">652</a>
<a href="#653" id="653">653</a>
<a href="#654" id="654">654</a>
<a href="#655" id="655">655</a>
<a href="#656" id="656">656</a>
<a href="#657" id="657">657</a>
<a href="#658" id="658">658</a>
<a href="#659" id="659">659</a>
<a href="#660" id="660">660</a>
<a href="#661" id="661">661</a>
<a href="#662" id="662">662</a>
<a href="#663" id="663">663</a>
<a href="#664" id="664">664</a>
<a href="#665" id="665">665</a>
<a href="#666" id="666">666</a>
<a href="#667" id="667">667</a>
<a href="#668" id="668">668</a>
<a href="#669" id="669">669</a>
<a href="#670" id="670">670</a>
<a href="#671" id="671">671</a>
<a href="#672" id="672">672</a>
<a href="#673" id="673">673</a>
<a href="#674" id="674">674</a>
<a href="#675" id="675">675</a>
<a href="#676" id="676">676</a>
<a href="#677" id="677">677</a>
<a href="#678" id="678">678</a>
<a href="#679" id="679">679</a>
<a href="#680" id="680">680</a>
<a href="#681" id="681">681</a>
<a href="#682" id="682">682</a>
<a href="#683" id="683">683</a>
<a href="#684" id="684">684</a>
<a href="#685" id="685">685</a>
<a href="#686" id="686">686</a>
<a href="#687" id="687">687</a>
<a href="#688" id="688">688</a>
<a href="#689" id="689">689</a>
<a href="#690" id="690">690</a>
<a href="#691" id="691">691</a>
<a href="#692" id="692">692</a>
<a href="#693" id="693">693</a>
<a href="#694" id="694">694</a>
<a href="#695" id="695">695</a>
<a href="#696" id="696">696</a>
<a href="#697" id="697">697</a>
<a href="#698" id="698">698</a>
<a href="#699" id="699">699</a>
<a href="#700" id="700">700</a>
<a href="#701" id="701">701</a>
<a href="#702" id="702">702</a>
<a href="#703" id="703">703</a>
<a href="#704" id="704">704</a>
<a href="#705" id="705">705</a>
<a href="#706" id="706">706</a>
<a href="#707" id="707">707</a>
<a href="#708" id="708">708</a>
<a href="#709" id="709">709</a>
<a href="#710" id="710">710</a>
<a href="#711" id="711">711</a>
<a href="#712" id="712">712</a>
<a href="#713" id="713">713</a>
<a href="#714" id="714">714</a>
<a href="#715" id="715">715</a>
<a href="#716" id="716">716</a>
<a href="#717" id="717">717</a>
<a href="#718" id="718">718</a>
<a href="#719" id="719">719</a>
<a href="#720" id="720">720</a>
<a href="#721" id="721">721</a>
<a href="#722" id="722">722</a>
<a href="#723" id="723">723</a>
<a href="#724" id="724">724</a>
<a href="#725" id="725">725</a>
<a href="#726" id="726">726</a>
<a href="#727" id="727">727</a>
<a href="#728" id="728">728</a>
<a href="#729" id="729">729</a>
<a href="#730" id="730">730</a>
<a href="#731" id="731">731</a>
<a href="#732" id="732">732</a>
<a href="#733" id="733">733</a>
<a href="#734" id="734">734</a>
<a href="#735" id="735">735</a>
<a href="#736" id="736">736</a>
<a href="#737" id="737">737</a>
<a href="#738" id="738">738</a>
<a href="#739" id="739">739</a>
<a href="#740" id="740">740</a>
<a href="#741" id="741">741</a>
<a href="#742" id="742">742</a>
<a href="#743" id="743">743</a>
<a href="#744" id="744">744</a>
<a href="#745" id="745">745</a>
<a href="#746" id="746">746</a>
<a href="#747" id="747">747</a>
<a href="#748" id="748">748</a>
<a href="#749" id="749">749</a>
<a href="#750" id="750">750</a>
<a href="#751" id="751">751</a>
<a href="#752" id="752">752</a>
<a href="#753" id="753">753</a>
<a href="#754" id="754">754</a>
<a href="#755" id="755">755</a>
<a href="#756" id="756">756</a>
<a href="#757" id="757">757</a>
<a href="#758" id="758">758</a>
<a href="#759" id="759">759</a>
<a href="#760" id="760">760</a>
<a href="#761" id="761">761</a>
<a href="#762" id="762">762</a>
<a href="#763" id="763">763</a>
<a href="#764" id="764">764</a>
<a href="#765" id="765">765</a>
<a href="#766" id="766">766</a>
<a href="#767" id="767">767</a>
<a href="#768" id="768">768</a>
<a href="#769" id="769">769</a>
<a href="#770" id="770">770</a>
<a href="#771" id="771">771</a>
<a href="#772" id="772">772</a>
<a href="#773" id="773">773</a>
<a href="#774" id="774">774</a>
<a href="#775" id="775">775</a>
<a href="#776" id="776">776</a>
<a href="#777" id="777">777</a>
<a href="#778" id="778">778</a>
<a href="#779" id="779">779</a>
<a href="#780" id="780">780</a>
<a href="#781" id="781">781</a>
<a href="#782" id="782">782</a>
<a href="#783" id="783">783</a>
<a href="#784" id="784">784</a>
<a href="#785" id="785">785</a>
<a href="#786" id="786">786</a>
<a href="#787" id="787">787</a>
<a href="#788" id="788">788</a>
<a href="#789" id="789">789</a>
<a href="#790" id="790">790</a>
<a href="#791" id="791">791</a>
<a href="#792" id="792">792</a>
<a href="#793" id="793">793</a>
<a href="#794" id="794">794</a>
<a href="#795" id="795">795</a>
<a href="#796" id="796">796</a>
<a href="#797" id="797">797</a>
<a href="#798" id="798">798</a>
<a href="#799" id="799">799</a>
<a href="#800" id="800">800</a>
<a href="#801" id="801">801</a>
<a href="#802" id="802">802</a>
<a href="#803" id="803">803</a>
<a href="#804" id="804">804</a>
<a href="#805" id="805">805</a>
<a href="#806" id="806">806</a>
<a href="#807" id="807">807</a>
<a href="#808" id="808">808</a>
<a href="#809" id="809">809</a>
<a href="#810" id="810">810</a>
<a href="#811" id="811">811</a>
<a href="#812" id="812">812</a>
<a href="#813" id="813">813</a>
<a href="#814" id="814">814</a>
<a href="#815" id="815">815</a>
<a href="#816" id="816">816</a>
<a href="#817" id="817">817</a>
<a href="#818" id="818">818</a>
<a href="#819" id="819">819</a>
<a href="#820" id="820">820</a>
<a href="#821" id="821">821</a>
<a href="#822" id="822">822</a>
<a href="#823" id="823">823</a>
<a href="#824" id="824">824</a>
<a href="#825" id="825">825</a>
<a href="#826" id="826">826</a>
<a href="#827" id="827">827</a>
<a href="#828" id="828">828</a>
<a href="#829" id="829">829</a>
<a href="#830" id="830">830</a>
<a href="#831" id="831">831</a>
<a href="#832" id="832">832</a>
<a href="#833" id="833">833</a>
<a href="#834" id="834">834</a>
<a href="#835" id="835">835</a>
<a href="#836" id="836">836</a>
<a href="#837" id="837">837</a>
<a href="#838" id="838">838</a>
<a href="#839" id="839">839</a>
<a href="#840" id="840">840</a>
<a href="#841" id="841">841</a>
<a href="#842" id="842">842</a>
<a href="#843" id="843">843</a>
<a href="#844" id="844">844</a>
<a href="#845" id="845">845</a>
<a href="#846" id="846">846</a>
<a href="#847" id="847">847</a>
<a href="#848" id="848">848</a>
<a href="#849" id="849">849</a>
<a href="#850" id="850">850</a>
<a href="#851" id="851">851</a>
<a href="#852" id="852">852</a>
<a href="#853" id="853">853</a>
<a href="#854" id="854">854</a>
<a href="#855" id="855">855</a>
<a href="#856" id="856">856</a>
<a href="#857" id="857">857</a>
<a href="#858" id="858">858</a>
<a href="#859" id="859">859</a>
<a href="#860" id="860">860</a>
<a href="#861" id="861">861</a>
<a href="#862" id="862">862</a>
<a href="#863" id="863">863</a>
<a href="#864" id="864">864</a>
<a href="#865" id="865">865</a>
<a href="#866" id="866">866</a>
<a href="#867" id="867">867</a>
<a href="#868" id="868">868</a>
<a href="#869" id="869">869</a>
<a href="#870" id="870">870</a>
<a href="#871" id="871">871</a>
<a href="#872" id="872">872</a>
<a href="#873" id="873">873</a>
<a href="#874" id="874">874</a>
<a href="#875" id="875">875</a>
<a href="#876" id="876">876</a>
<a href="#877" id="877">877</a>
<a href="#878" id="878">878</a>
<a href="#879" id="879">879</a>
<a href="#880" id="880">880</a>
<a href="#881" id="881">881</a>
<a href="#882" id="882">882</a>
<a href="#883" id="883">883</a>
<a href="#884" id="884">884</a>
<a href="#885" id="885">885</a>
<a href="#886" id="886">886</a>
<a href="#887" id="887">887</a>
<a href="#888" id="888">888</a>
<a href="#889" id="889">889</a>
<a href="#890" id="890">890</a>
<a href="#891" id="891">891</a>
<a href="#892" id="892">892</a>
<a href="#893" id="893">893</a>
<a href="#894" id="894">894</a>
<a href="#895" id="895">895</a>
<a href="#896" id="896">896</a>
<a href="#897" id="897">897</a>
<a href="#898" id="898">898</a>
<a href="#899" id="899">899</a>
<a href="#900" id="900">900</a>
<a href="#901" id="901">901</a>
<a href="#902" id="902">902</a>
<a href="#903" id="903">903</a>
<a href="#904" id="904">904</a>
<a href="#905" id="905">905</a>
<a href="#906" id="906">906</a>
<a href="#907" id="907">907</a>
<a href="#908" id="908">908</a>
<a href="#909" id="909">909</a>
<a href="#910" id="910">910</a>
<a href="#911" id="911">911</a>
<a href="#912" id="912">912</a>
<a href="#913" id="913">913</a>
<a href="#914" id="914">914</a>
<a href="#915" id="915">915</a>
<a href="#916" id="916">916</a>
<a href="#917" id="917">917</a>
<a href="#918" id="918">918</a>
<a href="#919" id="919">919</a>
<a href="#920" id="920">920</a>
<a href="#921" id="921">921</a>
<a href="#922" id="922">922</a>
<a href="#923" id="923">923</a>
<a href="#924" id="924">924</a>
<a href="#925" id="925">925</a>
<a href="#926" id="926">926</a>
<a href="#927" id="927">927</a>
<a href="#928" id="928">928</a>
<a href="#929" id="929">929</a>
<a href="#930" id="930">930</a>
<a href="#931" id="931">931</a>
<a href="#932" id="932">932</a>
<a href="#933" id="933">933</a>
</pre></div><pre class="rust"><code><span class="kw">use </span>std::cmp::{min, Ordering};
<span class="kw">use </span>std::io::{<span class="self">self</span>, Error, ErrorKind, Write};

<span class="doccomment">/** PaddingMap represents a mapping between data and its padded equivalent.

The padding process takes a *byte-aligned stream* of unpadded *raw* data
as input and returns another byte stream where padding is applied every
`data_bits` to align them to the byte boundary (`element_bits`). The
(inverse) *unpadding* process maps that output back to the raw input
that generated it.

# Padded layout

At the *byte-level*, the padded layout is:

```text
      (full element)              (full)                 (incomplete)
||  data_bits  pad_bits  ||  data_bits  pad_bits  ||  some_data  (no_padding)
                         ^^                               ^^
                  element boundary                (some_data &lt; data_bits)
                   (byte-aligned)
```

Each *element* is a byte-aligned stream comprised of a *full unit* of `data_bits`
with `pad_bits` at the end to byte-align it (where `pad_bits` is less than a byte,
this is a *sub-byte padding* scheme). After the last element boundary there may be
an incomplete unit of data (`some_data`) with a length smaller than `data_bits`
that hasn't been padded. The padding rules are:
  1. Padding is always applied to a full unit of `data_bits`.
  2. A full data unit cannot exist without its corresponding padding.
  3. A unit of padding is complete by definition: padding can only be
     applied fully to each element.
  4. If there is padding present then there has to be an already formed
     element there (an element is full if and only if its data unit is full).

# Last byte

When returning the byte-aligned output generated from the padded *bitstream*
(since the padding is done at the bit-level) the conversion results in the
last byte having (potentially) more bits than desired. At the *bit-level*
the layout of the last byte can either be a complete element (bits of raw
data followed by the corresponding padding bits) or an incomplete unit of
data: some number of *valid* data (D) bits followed by any number of *extra*
bits (X) necessary to complete the byte-aligned stream:

```text
 |   D   D   D   D   X   X   X   X   |
         (data)         (extra)      ^ byte boundary (end of output)
```

(This diagram is just for illustrative purposes, we actually return the output
 in little-endian order, see `BitVecLEu8`).

It's important to distinguish these extra bits (generated as a side
effect of the conversion to a byte-aligned stream) from the padding bits
themselves introduced in the padding process: even though both will be
left with a zero value, these extra bits are a place-holder for the actual
raw data bits needed to complete the current unit of data (and hence also
the element, with the corresponding padding bits added after it). Since
extra bits are only a product of an incomplete unit of data there can't
be extra bits after padding bits.

There's no metadata signaling the number of extra bits present in the
last byte in any given padded layout, this is deduced from the fact
that there's only a single number of valid data bits in the last byte,
and hence a number of data bits in total, that maps to a byte-aligned
(multiple of 8) raw data stream that could have been used as input.

# Example: `FR32_PADDING_MAP`

In this case the `PaddingMap` is defined with a data unit of 254 bits that
are byte aligned to a 256-bit (32-byte) element. If the user writes as input,
say, 40 bytes (320 bits) of raw input data to the padding process the resulting
layout would be, at the element (byte) level:

```text
      (full element: 32 bytes)         (incomplete: 9 bytes)
||  data_bits: 254  pad_bits: 2  ||   some_data: 66 bits (+ extra bits)
                                 ^^
                          element boundary
```

That is, of the original 320 bits (40 bytes) of raw input data, 254 are
padded in the first element and the remaining 66 bits form the incomplete
data unit after it, which is aligned to 9 bytes. At the bit level, that
last incomplete byte will have 2 valid bits and 6 extra bits.

# Alignment of raw data bytes in the padded output

This section is not necessary to use this structure but it does help to
reason about it. By the previous definition, the raw data bits *embedded*
in the padded layout are not necessarily grouped in the same byte units
as in the original raw data input (due to the inclusion of the padding
bits interleaved in that bit stream, which keep shifting the data bits
after them).

This can also be stated as: the offsets of the bits (relative to the byte
they belong to, i.e., *bit-offset*) in the raw data input won't necessarily
match the bit-offsets of the raw data bits embedded in the padded layout.
The consequence is that each raw byte written to the padded layout won't
result in a byte-aligned bit stream output, i.e., it may cause the appearance
of extra bits (to convert the output to a byte-aligned stream).

There are portions of the padded layout, however, where this alignment does
happen. Particularly, when the padded layout accumulates enough padding bits
that they altogether add up to a byte, the following raw data byte written
will result in a byte-aligned output, and the same is true for all the other
raw data byte that follow it up until the element end, where new padding bits
shift away this alignment. (The other obvious case is the first element, which,
with no padded bits in front of it, has by definition all its embedded raw data
bytes aligned, independently of the `data_bits`/`pad_bits` configuration used.)

In the previous example, that happens after the fourth element, where 4 units
of `pad_bits` add up to one byte and all of the raw data bytes in the fifth
element will keep its original alignment from the byte input stream (and the
same will happen with every other element multiple of 4). When that fourth
element is completed we have then 127 bytes of raw data and 1 byte of padding
(totalling 32 * 4 = 128 bytes of padded output), so the interval of raw data
bytes `[127..159]` (indexed like this in the input raw data stream) will keep
its original alignment when embedded in the padded layout, i.e., every raw
data byte written will keep the output bit stream byte-aligned (without extra
bits). (Technically, the last byte actually won't be a full byte since its last
bits will be replaced by padding).

# Key terms

Collection of terms introduced in this documentation (with the format
`*&lt;new-term&gt;*`). This section doesn't provide a self-contained definition
of them (to avoid unnecessary repetition), it just provides (when appropriate)
an additional summary of what was already discussed.

 * Raw data: unpadded user-supplied data (we don't use the *unpadded* term
   to avoid excessive *padding* suffixes in the code). Padding (data) bits.
 * Element: byte-aligned stream consisting of a full unit of data plus the
   padding bits.
 * Full unit of raw `data_bits` (always followed by padding). Incomplete unit,
   not followed by padding, doesn't form an element.
 * Byte-aligned stream: always input and output of the (un)padding process,
   either as raw data or padded (using the term "byte-aligned" and not "byte
   stream" to stress the boundaries of the elements). Bit streams: used internally
   when padding data (never returned as bits).
 * Valid data bits, only in the context of the last byte of a byte-aligned stream
   generated from the padding process. Extra bits: what's left unused of the last
   byte (in a way the extra bits are the padding at the byte-level, but we don't
   use that term here to avoid confusions).
 * Sub-byte padding.
 * Bit-offset: offset of a bit within the byte it belongs to, ranging in `[0..8]`.
 * Embedded raw data: view of the input raw data when it has been decomposed in
   bit streams and padded in the resulting output.

**/
</span><span class="attr">#[derive(Debug)]
</span><span class="kw">struct </span>PaddingMap {
    <span class="doccomment">/// The number of bits of raw data in an element.
    </span>data_bits: usize,
    <span class="doccomment">/// Number of bits in an element: `data_bits` + `pad_bits()`. Its value
    /// is fixed to the next byte-aligned size after `data_bits` (sub-byte padding).
    </span>element_bits: usize,
}
<span class="comment">// TODO: Optimization: Evaluate saving the state of a (un)padding operation
// inside (e.g., as a cursor like in `BitVec`), maybe not in this structure but
// in a new `Padder` structure which would remember the positions (remaining
// data bits in the element, etc.) to avoid recalculating them each time across
// different (un)pad calls.

// This is the padding map corresponding to Fr32.
// Most of the code in this module is general-purpose and could move elsewhere.
// The application-specific wrappers which implicitly use Fr32 embed the FR32_PADDING_MAP.
</span><span class="kw">const </span>FR32_PADDING_MAP: PaddingMap = PaddingMap {
    data_bits: <span class="number">254</span>,
    element_bits: <span class="number">256</span>,
};

<span class="kw">pub fn </span>to_unpadded_bytes(padded_bytes: u64) -&gt; u64 {
    FR32_PADDING_MAP.transform_byte_offset(padded_bytes <span class="kw">as </span>usize, <span class="bool-val">false</span>) <span class="kw">as </span>u64
}

<span class="kw">pub fn </span>to_padded_bytes(unpadded_bytes: usize) -&gt; usize {
    FR32_PADDING_MAP.transform_byte_offset(unpadded_bytes, <span class="bool-val">true</span>)
}

<span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////
// BitByte represents a size expressed in bytes extended
// with bit precision, that is, not rounded.
// Invariant: it is an error for bits to be &gt; 7.
</span><span class="attr">#[derive(Debug)]
</span><span class="kw">struct </span>BitByte {
    bytes: usize,
    bits: usize,
}

<span class="kw">impl </span>BitByte {
    <span class="comment">// Create a BitByte from number of bits. Guaranteed to return a well-formed value (bits &lt; 8)
    </span><span class="kw">fn </span>from_bits(bits: usize) -&gt; BitByte {
        BitByte {
            bytes: bits / <span class="number">8</span>,
            bits: bits % <span class="number">8</span>,
        }
    }

    <span class="comment">// How many bits in the BitByte (inverse of from_bits).
    </span><span class="kw">fn </span>total_bits(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; usize {
        <span class="self">self</span>.bytes * <span class="number">8 </span>+ <span class="self">self</span>.bits
    }

    <span class="comment">// How many distinct bytes are needed to represent data of this size?
    </span><span class="kw">fn </span>bytes_needed(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; usize {
        <span class="self">self</span>.bytes + <span class="kw">if </span><span class="self">self</span>.bits == <span class="number">0 </span>{ <span class="number">0 </span>} <span class="kw">else </span>{ <span class="number">1 </span>}
    }
}

<span class="kw">impl </span>PaddingMap {
    <span class="kw">fn </span>pad_bits(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; usize {
        <span class="self">self</span>.element_bits - <span class="self">self</span>.data_bits
    }

    <span class="comment">// Transform an offset (either a position or a size) *expressed in
    // bits* in a raw byte-aligned data stream to its equivalent in a
    // generated padded bit stream, that is, not byte aligned (so we
    // don't count the extra bits here). If `padding` is `false` calculate
    // the inverse transformation.
    </span><span class="kw">fn </span>transform_bit_offset(<span class="kw-2">&amp;</span><span class="self">self</span>, pos: usize, padding: bool) -&gt; usize {
        <span class="comment">// Set the sizes we're converting to and from.
        </span><span class="kw">let </span>(from_size, to_size) = <span class="kw">if </span>padding {
            (<span class="self">self</span>.data_bits, <span class="self">self</span>.element_bits)
        } <span class="kw">else </span>{
            (<span class="self">self</span>.element_bits, <span class="self">self</span>.data_bits)
        };

        <span class="comment">// For both the padding and unpadding cases the operation is the same.
        // The quotient is the number of full, either elements, in the padded layout,
        // or groups of `data_bits`, in the raw data input (that will be converted
        // to full elements).
        // The remainder (in both cases) is the last *incomplete* part of either of
        // the two. Even in the padded layout, if there is an incomplete element it
        // has to consist *only* of data (see `PaddingMap#padded-layout`). That amount
        // of spare raw data doesn't need conversion, it can just be added to the new
        // position.
        </span><span class="kw">let </span>(full_elements, incomplete_data) = div_rem(pos, from_size);
        (full_elements * to_size) + incomplete_data
    }

    <span class="comment">// Similar to `transform_bit_pos` this function transforms an offset
    // expressed in bytes, that is, we are taking into account the extra
    // bits here.
    // TODO: Evaluate the relationship between this function and `transform_bit_offset`,
    // it seems the two could be merged, or at least restructured to better expose
    // their differences.
    </span><span class="kw">fn </span>transform_byte_offset(<span class="kw-2">&amp;</span><span class="self">self</span>, pos: usize, padding: bool) -&gt; usize {
        <span class="kw">let </span>transformed_bit_pos = <span class="self">self</span>.transform_bit_offset(pos * <span class="number">8</span>, padding);

        <span class="kw">let </span>transformed_byte_pos = transformed_bit_pos <span class="kw">as </span>f64 / <span class="number">8.</span>;
        <span class="comment">// TODO: Optimization: It might end up being cheaper to avoid this
        // float conversion and use / and %.

        // When padding, the final bits in the bit stream will grow into the
        // last (potentially incomplete) byte of the byte stream, so round the
        // number up (`ceil`). When unpadding, there's no way to know a priori
        // how many valid bits are in the last byte, we have to choose the number
        // that fits in a byte-aligned raw data stream, so round the number down
        // to that (`floor`).
        </span>(<span class="kw">if </span>padding {
            transformed_byte_pos.ceil()
        } <span class="kw">else </span>{
            transformed_byte_pos.floor()
        }) <span class="kw">as </span>usize
    }

    <span class="comment">// From the `position` specified, it returns:
    // - the absolute position of the start of the next element,
    //   in bytes (since elements -with padding- are byte aligned).
    // - the number of bits left to read (write) from (to) the current
    //   data unit (assuming it's full).
    </span><span class="kw">fn </span>next_boundary(<span class="kw-2">&amp;</span><span class="self">self</span>, position: <span class="kw-2">&amp;</span>BitByte) -&gt; (usize, usize) {
        <span class="kw">let </span>position_bits = position.total_bits();

        <span class="kw">let </span>(<span class="kw">_</span>, bits_after_last_boundary) = div_rem(position_bits, <span class="self">self</span>.element_bits);

        <span class="kw">let </span>remaining_data_unit_bits = <span class="self">self</span>.data_bits - bits_after_last_boundary;

        <span class="kw">let </span>next_element_position_bits = position_bits + remaining_data_unit_bits + <span class="self">self</span>.pad_bits();

        (next_element_position_bits / <span class="number">8</span>, remaining_data_unit_bits)
    }
}

<span class="attr">#[inline]
</span><span class="kw">fn </span>div_rem(a: usize, b: usize) -&gt; (usize, usize) {
    <span class="kw">let </span>div = a / b;
    <span class="kw">let </span>rem = a % b;
    (div, rem)
}

<span class="comment">// TODO: The following extraction functions could be moved to a different file.

</span><span class="doccomment">/** Shift an `amount` of bits from the `input` in the direction indicated by `is_left`.

This function tries to imitate the behavior of `shl` and `shr` of a
`BitVec&lt;LittleEndian, u8&gt;`, where the inner vector is traversed one byte
at a time (`u8`), and inside each byte, bits are traversed (`LittleEndian`)
from LSB ("right") to MSB ("left"). For example, the bits in the this two-byte
slice will be traversed according to their numbering:

```text
ADDR     |  7  6  5  4  3  2  1  0  |

ADDR +1  |  F  E  D  C  B  A  9  8  |
```

`BitVec` uses the opposite naming convention than this function, shifting left
here is equivalent to `shr` there, and shifting right to `shl`.

If shifting in the left direction, the `input` is expanded by one extra byte to
accommodate the overflow (instead of just discarding it, which is what's done
in the right direction).

The maximum `amount` to shift is 7 (and the minimum is 1), that is, we always
shift less than a byte. This precondition is only checked during testing (with
`debug_assert!`) for performance reasons, it is up to the caller to enforce it.

# Examples

Shift the `input` (taken from the diagram above) left by an `amount` of 3 bits,
growing the output slice:

```text
ADDR     |  4  3  2  1  0  _  _  _  |  Filled with zeros.

ADDR +1  |  C  B  A  9  8  7  6  5  |

ADDR +2  |  _  _  _  _  _  F  E  D  |  The overflow of the last input byte
                                               is moved to this (new) byte.
```

Same, but shift right:

```text
ADDR     |  A  9  8  7  6  5  4  3  |  The overflow `[2,1,0]` is just discarded,
                                                         the slice doesn't grow.
ADDR +1  |  _  _  _  F  E  D  C  B  |
```

(Note: `0`, `1`, `2`, etc. are bits identified by their original position,
`_` means a bit left at zero after shifting, to avoid confusions with
the unique bit `0`, that just *started* at that position but doesn't
necessarily carry that value.)

**/
</span><span class="kw">fn </span>shift_bits(input: <span class="kw-2">&amp;</span>[u8], amount: usize, is_left: bool) -&gt; Vec&lt;u8&gt; {
    <span class="macro">debug_assert!</span>(amount &gt;= <span class="number">1</span>);
    <span class="macro">debug_assert!</span>(amount &lt;= <span class="number">7</span>);

    <span class="comment">// Create the `output` vector from the original input values, extending
    // its size by one if shifting left.
    </span><span class="kw">let </span><span class="kw-2">mut </span>output = Vec::with_capacity(input.len() + <span class="kw">if </span>is_left { <span class="number">1 </span>} <span class="kw">else </span>{ <span class="number">0 </span>});
    output.extend_from_slice(input);
    <span class="kw">if </span>is_left {
        output.push(<span class="number">0</span>);
    }
    <span class="comment">// TODO: Is there a cleaner way to do this? Is the extra byte worth the initial
    // `with_capacity` call?

    // Split the shift in two parts. First, do a simple bit shift (losing the
    // overflow) for each byte, then, in a second pass, recover the lost overflow
    // from the `input`. The advantage of splitting it like this is that the place-holder
    // spaces are already being cleared with zeros to just join the overflow part with an
    // single `OR` operation (instead of assembling both parts together at the same time
    // which requires an extra clear operation with a mask of zeros).
    </span><span class="kw">for </span>output_byte <span class="kw">in </span>output.iter_mut().take(input.len()) {
        <span class="kw">if </span>is_left {
            <span class="kw-2">*</span>output_byte &lt;&lt;= amount;
        } <span class="kw">else </span>{
            <span class="kw-2">*</span>output_byte &gt;&gt;= amount;
        }
    }

    <span class="kw">if </span>is_left {
        <span class="comment">// The `output` looks at this point like this (following the original
        // example):
        //
        // ADDR     |  4  3  2  1  0  _  _  _  |
        //
        // ADDR +1  |  C  B  A  9  8  _  _  _  |
        //
        // ADDR +2  |  _  _  _  _  _  _  _  _  |  Extra byte allocated to extend the `input`,
        //                                            hasn't been modified in the first pass.
        //
        // We need to recover the overflow of each shift (e.g., `[7,6,5]` from
        // the first byte and `[F,E,D]` from the second) and move it to the next
        // byte, shifting it to place it at the "start" (in the current ordering
        // that means aligning it to the LSB). For example, the overflow of (also)
        // `amount` bits from the first byte is:
        //
        // ADDR     |  7  6  5  4  3  2  1  0  |
        //             +-----+
        //           overflow lost
        //
        // and it's "recovered" with a shift in the opposite direction, which both
        // positions it in the correct place *and* leaves cleared the rest of the
        // bits to be able to `OR` (join) it with the next byte of `output` (shifted
        // in the first pass):
        //
        // (`output` so far)
        // ADDR +1  |  C  B  A  9  8  _  _  _  |    +
        //                                          |
        // (shifted overflow                        |  join both (`|=`)
        //      from `input`)                       |
        // ADDR     |  _  _  _  _  _  7  6  5  |    V
        //             +-------------&gt;
        //
        </span><span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..input.len() {
            <span class="kw">let </span>overflow = input[i] &gt;&gt; (<span class="number">8 </span>- amount);
            output[i + <span class="number">1</span>] |= overflow;
        }
    } <span class="kw">else </span>{
        <span class="comment">// The overflow handling in the right shift follows the same logic as the left
        // one with just two differences: (1) the overflow goes to the *previous* byte
        // in memory and (2) the overflow of the first byte is discarded (hence the `for`
        // loop iterates just `input.len` *minus one* positions).
        </span><span class="kw">for </span>i <span class="kw">in </span><span class="number">1</span>..input.len() {
            <span class="kw">let </span>overflow = input[i] &lt;&lt; (<span class="number">8 </span>- amount);
            output[i - <span class="number">1</span>] |= overflow;
        }
    }

    <span class="comment">// TODO: Optimization: Join both passes in one `for` loop for cache
    // efficiency (do everything we need to do in the same address once).
    // (This is low priority since we normally shift small arrays -32 byte
    // elements- per call.)

    </span>output
}

<span class="doccomment">/** Extract bits and relocate them.

Extract `num_bits` from the `input` starting at absolute `pos` (expressed in
bits). Format the extracted bit stream as a byte stream `output` (in a `Vec&lt;u8&gt;`)
where the extracted bits start at `new_offset` bits in the first byte (i.e.,
`new_offset` can't be bigger than 7) allowing them to be relocated from their
original bit-offset (encoded in `pos`). The rest of the bits (below `new_offset`
and after the extracted `num_bits`) are left at zero (to prepare them to be
joined with another extracted `output`). This function follows the ordering in
`BitVec&lt;LittleEndian, u8&gt;` (see `shift_bits` for more details).

The length of the input must be big enough to perform the extraction
of `num_bits`. This precondition is only checked during testing (with
`debug_assert!`) for performance reasons, it is up to the caller to enforce it.

# Example

Taking as `input` the original two-byte layout from `shift_bits`, extracting 4
`num_bits` from `pos` 12 and relocating them in `new_offset` 2 would result in
an `output` of a single byte like:

```text
ADDR     |  _  _  F  E  D  C  _  _  |
```

(The second byte in `ADDR +1` has been dropped after the extraction
as it's no longer needed.)

**/
</span><span class="comment">//
// TODO: Replace the byte terminology for a generic term that can mean
// anything that implements the `bitvec::Bits` trait (`u8`, `u32`, etc.).
// `BitVec` calls it "element" but that's already used here (this function
// may need to be moved elsewhere which would allow to reuse that term).
// This also will imply removing the hardcoded `8`s (size of byte).
</span><span class="attr">#[inline]
</span><span class="kw">fn </span>extract_bits_and_shift(input: <span class="kw-2">&amp;</span>[u8], pos: usize, num_bits: usize, new_offset: usize) -&gt; Vec&lt;u8&gt; {
    <span class="macro">debug_assert!</span>(input.len() * <span class="number">8 </span>&gt;= pos + num_bits);
    <span class="macro">debug_assert!</span>(new_offset &lt;= <span class="number">7</span>);

    <span class="comment">// 1. Trim the whole bytes (before and after) we don't need for the
    //    extraction (we don't want to waste shift operations on them).
    // 2. Shift from the original `pos` to the `new_offset`.
    // 3. Trim the bits in the first and last byte we also don't need.
    //
    // TODO: Does (3) need to happen *after* the shift in (2)? It feels
    // more natural but can't we just trim everything in (1)?

    // Determine from `pos` the number of full bytes that can be completely skipped
    // (`skip_bytes`), and the number of bits within the first byte of interest that
    // we'll start extracting from (`extraction_offset`).
    </span><span class="kw">let </span>(skip_bytes, extraction_offset) = div_rem(pos, <span class="number">8</span>);

    <span class="comment">// (1).
    </span><span class="kw">let </span>input = <span class="kw-2">&amp;</span>input[skip_bytes..];
    <span class="kw">let </span>input = <span class="kw-2">&amp;</span>input[..BitByte::from_bits(extraction_offset + num_bits).bytes_needed()];

    <span class="comment">// (2).
    </span><span class="kw">let </span><span class="kw-2">mut </span>output = <span class="kw">match </span>new_offset.cmp(<span class="kw-2">&amp;</span>extraction_offset) {
        Ordering::Less =&gt; {
            <span class="comment">// Shift right.
            </span>shift_bits(input, extraction_offset - new_offset, <span class="bool-val">false</span>)
        }
        Ordering::Greater =&gt; {
            <span class="comment">// Shift left.
            </span>shift_bits(input, new_offset - extraction_offset, <span class="bool-val">true</span>)
        }
        Ordering::Equal =&gt; {
            <span class="comment">// No shift needed, take the `input` as is.
            </span>input.to_vec()
        }
    };

    <span class="comment">// After the shift we may not need the last byte of the `output` (either
    // because the left shift extended it by one byte or because the right shift
    // move the extraction span below that threshold).
    </span><span class="kw">if </span>output.len() &gt; BitByte::from_bits(new_offset + num_bits).bytes_needed() {
        output.pop();
    }
    <span class="comment">// TODO: Optimization: A more specialized shift would have just dropped
    // that byte (we would need to pass it the `num_bits` we want).

    // (3).
    </span><span class="kw">if </span>new_offset != <span class="number">0 </span>{
        clear_right_bits(output.first_mut().expect(<span class="string">"output is empty"</span>), new_offset);
    }
    <span class="kw">let </span>end_offset = (new_offset + num_bits) % <span class="number">8</span>;
    <span class="kw">if </span>end_offset != <span class="number">0 </span>{
        clear_left_bits(output.last_mut().expect(<span class="string">"output is empty"</span>), end_offset);
    }

    output
}

<span class="comment">// Set to zero all the bits to the "left" of the `offset` including
// it, that is, [MSB; `offset`].
</span><span class="attr">#[inline]
</span><span class="kw">fn </span>clear_left_bits(byte: <span class="kw-2">&amp;mut </span>u8, offset: usize) {
    <span class="kw-2">*</span>(byte) &amp;= (<span class="number">1 </span>&lt;&lt; offset) - <span class="number">1
</span>}

<span class="comment">// Set to zero all the bits to the "right" of the `offset` excluding
// it, that is, (`offset`; LSB].
</span><span class="attr">#[inline]
</span><span class="kw">fn </span>clear_right_bits(byte: <span class="kw-2">&amp;mut </span>u8, offset: usize) {
    <span class="kw-2">*</span>(byte) &amp;= !((<span class="number">1 </span>&lt;&lt; offset) - <span class="number">1</span>)
}

<span class="doccomment">/** Padding process.

Read a `source` of raw byte-aligned data, pad it in a bit stream and
write a byte-aligned version of it in the `target`. The `target` needs
to implement (besides `Write`) the `Read` and `Seek` traits since the
last byte written may be incomplete and will need to be rewritten.

The reader will always be byte-aligned, the writer will operate with
bit precision since we may have (when calling this function multiple
times) a written `target` with extra bits (that need to be overwritten)
and also incomplete data units.
The ideal alignment scenario is for the writer to be positioned at the
byte-aligned element boundary and just write whole chunks of `data_chunk_bits`
(full data units) followed by its corresponding padding. To get there then we
need to handle the potential bit-level misalignments:
  1. extra bits: the last byte is only partially valid so we
     need to get some bits from the `source` to overwrite them.
  2. Incomplete data unit: we need to fill the rest of it and add the padding
     to form a element that would position the writer at the desired boundary.
**/

</span><span class="comment">// offset and num_bytes are based on the unpadded data, so
// if [0, 1, ..., 255] was the original unpadded data, offset 3 and len 4 would return
// [3, 4, 5, 6].
</span><span class="kw">pub fn </span>write_unpadded&lt;W: <span class="question-mark">?</span>Sized&gt;(
    source: <span class="kw-2">&amp;</span>[u8],
    target: <span class="kw-2">&amp;mut </span>W,
    offset: usize,
    len: usize,
) -&gt; io::Result&lt;usize&gt;
<span class="kw">where
    </span>W: Write,
{
    <span class="comment">// Check that there's actually `len` raw data bytes encoded inside
    // `source` starting at `offset`.
    </span><span class="kw">let </span>read_pos = BitByte::from_bits(FR32_PADDING_MAP.transform_bit_offset(offset * <span class="number">8</span>, <span class="bool-val">true</span>));
    <span class="kw">let </span>raw_data_size = BitByte::from_bits(
        FR32_PADDING_MAP.transform_bit_offset(source.len() * <span class="number">8 </span>- read_pos.total_bits(), <span class="bool-val">false</span>),
    )
    .bytes_needed();
    <span class="kw">if </span>raw_data_size &lt; len {
        <span class="kw">return </span><span class="prelude-val">Err</span>(Error::new(
            ErrorKind::Other,
            <span class="macro">format!</span>(
                <span class="string">"requested extraction of {} raw data bytes when there's at most {} in the source"</span>,
                len, raw_data_size
            ),
        ));
    }

    <span class="comment">// In order to optimize alignment in the common case of writing from an aligned start,
    // we should make the chunk a multiple of 128 (4 full elements in the padded layout).
    // n was hand-tuned to do reasonably well in the benchmarks.
    </span><span class="kw">let </span>n = <span class="number">1000</span>;
    <span class="kw">let </span>chunk_size = <span class="number">128 </span>* n;

    <span class="kw">let </span><span class="kw-2">mut </span>written = <span class="number">0</span>;

    <span class="kw">let </span><span class="kw-2">mut </span>offset = offset;
    <span class="kw">let </span><span class="kw-2">mut </span>len = len;

    <span class="kw">for </span>chunk <span class="kw">in </span>source.chunks(chunk_size) {
        <span class="kw">let </span>write_len = min(len, chunk.len());

        written += write_unpadded_aux(<span class="kw-2">&amp;</span>FR32_PADDING_MAP, source, target, offset, write_len)<span class="question-mark">?</span>;
        offset += write_len;
        len -= write_len;
    }

    <span class="prelude-val">Ok</span>(written)
}

<span class="doccomment">/**  Unpadding process.

Read a `source` of padded data and recover from it the byte-aligned
raw data writing it in `target`, where `write_pos` specifies from which
byte of the raw data stream to start recovering to, up to `max_write_size`
bytes.

There are 3 limits that tell us how much padded data to process in
each iteration (`bits_to_extract`):
1. Element boundary: we can process only one element at a time (to be
   able to skip the padding bits).
2. End of `source`: no more data to read.
3. No more space to write the recovered raw data: we shouldn't write
   into the `target` beyond `max_write_size`.

The reader will generally operate with bit precision, even if the padded
layout is byte-aligned (no extra bits) the data inside it isn't (since
we pad at the bit-level).
**/
</span><span class="kw">fn </span>write_unpadded_aux&lt;W: <span class="question-mark">?</span>Sized&gt;(
    padding_map: <span class="kw-2">&amp;</span>PaddingMap,
    source: <span class="kw-2">&amp;</span>[u8],
    target: <span class="kw-2">&amp;mut </span>W,
    write_pos: usize,
    max_write_size: usize,
) -&gt; io::Result&lt;usize&gt;
<span class="kw">where
    </span>W: Write,
{
    <span class="comment">// Position of the reader in the padded bit stream layout, deduced from
    // the position of the writer (`write_pos`) in the raw data layout.
    </span><span class="kw">let </span><span class="kw-2">mut </span>read_pos = BitByte::from_bits(padding_map.transform_bit_offset(write_pos * <span class="number">8</span>, <span class="bool-val">true</span>));

    <span class="comment">// Specify the maximum data to recover (write) in bits, since the data unit
    // in the element (in contrast with the original raw data that generated it)
    // is not byte aligned.
    </span><span class="kw">let </span>max_write_size_bits = max_write_size * <span class="number">8</span>;

    <span class="comment">// Estimate how many bytes we'll need for the `raw_data` to allocate
    // them all at once. We need to take into account both how much do
    // we have left to read *and* write, and even then, since we may start
    // in the middle of an element (`write_pos`) there's some variability
    // as to how many padding bits will be encountered.
    // Allow then an *over*-estimation error of 1 byte: `transform_bit_offset`
    // has the implicit assumption that the data provided is starting at the
    // beginning of an element, i.e., the padding bits are as far as possible,
    // which maximizes the chances of not getting an extra `pad_bits` in the
    // `source` (which are unpadded away and not carried to the `target`). That
    // is, in this context `transform_bit_offset` is optimistic about the number
    // of raw data bits we'll be able to recover from a fixed number of `source`
    // bits.
    </span><span class="kw">let </span><span class="kw-2">mut </span>raw_data_size = BitByte::from_bits(
        padding_map.transform_bit_offset(source.len() * <span class="number">8 </span>- read_pos.total_bits(), <span class="bool-val">false</span>),
    )
    .bytes_needed();
    raw_data_size = min(raw_data_size, max_write_size);

    <span class="comment">// Recovered raw data unpadded from the `source` which will
    // be written to the `target`.
    </span><span class="kw">let </span><span class="kw-2">mut </span>raw_data: Vec&lt;u8&gt; = Vec::with_capacity(raw_data_size);

    <span class="comment">// Total number of raw data bits we have written (unpadded from the `source`).
    </span><span class="kw">let </span><span class="kw-2">mut </span>written_bits = <span class="number">0</span>;
    <span class="comment">// Bit offset within the last byte at which the next write needs to happen
    // (derived from `written_bits`), we keep track of this since we write in chunks
    // that may not be byte-aligned.
    </span><span class="kw">let </span><span class="kw-2">mut </span>write_bit_offset = <span class="number">0</span>;

    <span class="comment">// If there is no more data to read or no more space to write stop.
    </span><span class="kw">while </span>read_pos.bytes &lt; source.len() &amp;&amp; written_bits &lt; max_write_size_bits {
        <span class="comment">// (1): Find the element boundary and, assuming that there is a full
        //      unit of data (which actually may be incomplete), how many bits
        //      are left to read from `read_pos`.
        </span><span class="kw">let </span>(next_element_position, <span class="kw-2">mut </span>bits_to_extract) = padding_map.next_boundary(<span class="kw-2">&amp;</span>read_pos);

        <span class="comment">// (2): As the element may be incomplete check how much data is
        //      actually available so as not to access the `source` past
        //      its limit.
        </span>bits_to_extract = min(bits_to_extract, source.len() * <span class="number">8 </span>- read_pos.total_bits());

        <span class="comment">// (3): Don't read more than `max_write_size`.
        </span><span class="kw">let </span>bits_left_to_write = max_write_size_bits - written_bits;
        bits_to_extract = min(bits_to_extract, bits_left_to_write);

        <span class="comment">// Extract the next data unit from the element (or whatever space we
        // have left to write) and reposition it in the `write_bit_offset`.
        // N.B., the bit offset of the data in the original raw data byte
        // stream and the same data in the padded layout are not necessarily
        // the same (since the added padding bits shift it).
        </span><span class="kw">let </span><span class="kw-2">mut </span>recovered = extract_bits_and_shift(
            source,
            read_pos.total_bits(),
            bits_to_extract,
            write_bit_offset,
        );

        <span class="kw">if </span>write_bit_offset != <span class="number">0 </span>{
            <span class="comment">// Since the two data units we are joining are not byte-aligned we can't
            // just append the whole bytes to `raw_data`, we need to join the last
            // byte of the already written `raw_data` with the first one of data unit
            // `recovered` in this iteration. Since `extract_bits_and_shift` already
            // takes care of setting to zero the bits beyond the extraction limit we
            // can just `OR` the two.
            </span><span class="kw-2">*</span>(raw_data.last_mut().expect(<span class="string">"raw_data is empty"</span>)) |=
                <span class="kw-2">*</span>(recovered.first().expect(<span class="string">"recovered is empty"</span>));
            raw_data.append(<span class="kw-2">&amp;mut </span>recovered[<span class="number">1</span>..].to_vec());
        } <span class="kw">else </span>{
            raw_data.append(<span class="kw-2">&amp;mut </span>recovered);
        }

        written_bits += bits_to_extract;
        write_bit_offset = written_bits % <span class="number">8</span>;

        <span class="comment">// Position the reader in the next element boundary, this will be ignored
        // if we already hit limits (2) or (3) (in that case this was the last iteration).
        </span>read_pos = BitByte {
            bytes: next_element_position,
            bits: <span class="number">0</span>,
        };
    }

    <span class="comment">// TODO: Don't write the whole output into a huge BitVec.
    // Instead, write it incrementally –
    // but ONLY when the bits waiting in bits_out are byte-aligned. i.e. a multiple of 8

    // Check that our estimated size was correct, allow it to be overestimated
    // (not *under*) by 1 byte.
    </span><span class="macro">debug_assert!</span>(raw_data_size - raw_data.len() &lt;= <span class="number">1</span>);
    <span class="macro">debug_assert!</span>(raw_data_size &gt;= raw_data.len());

    target.write_all(<span class="kw-2">&amp;</span>raw_data)<span class="question-mark">?</span>;

    <span class="prelude-val">Ok</span>(raw_data.len())
}

<span class="attr">#[cfg(test)]
</span><span class="kw">mod </span>tests {
    <span class="kw">use super</span>::<span class="kw-2">*</span>;

    <span class="kw">use </span>std::io::{Cursor, Read};

    <span class="kw">use </span>bitvec::{order::Lsb0 <span class="kw">as </span>LittleEndian, vec::BitVec};
    <span class="kw">use </span>itertools::Itertools;
    <span class="kw">use </span>rand::{Rng, SeedableRng};
    <span class="kw">use </span>rand_xorshift::XorShiftRng;

    <span class="kw">use </span><span class="kw">crate</span>::Fr32Reader;

    <span class="kw">const </span>TEST_SEED: [u8; <span class="number">16</span>] = [
        <span class="number">0x59</span>, <span class="number">0x62</span>, <span class="number">0xbe</span>, <span class="number">0x5d</span>, <span class="number">0x76</span>, <span class="number">0x3d</span>, <span class="number">0x31</span>, <span class="number">0x8d</span>, <span class="number">0x17</span>, <span class="number">0xdb</span>, <span class="number">0x37</span>, <span class="number">0x32</span>, <span class="number">0x54</span>, <span class="number">0x06</span>, <span class="number">0xbc</span>,
        <span class="number">0xe5</span>,
    ];

    <span class="attr">#[test]
    </span><span class="kw">fn </span>test_position() {
        <span class="kw">let </span><span class="kw-2">mut </span>bits = <span class="number">0</span>;
        <span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..<span class="number">10 </span>{
            <span class="kw">for </span>j <span class="kw">in </span><span class="number">0</span>..<span class="number">8 </span>{
                <span class="kw">let </span>position = BitByte { bytes: i, bits: j };
                <span class="macro">assert_eq!</span>(position.total_bits(), bits);
                bits += <span class="number">1</span>;
            }
        }
    }

    <span class="comment">// Test the `extract_bits_le` function against the `BitVec` functionality
    // (assumed to be correct).
    </span><span class="attr">#[test]
    </span><span class="kw">fn </span>test_random_bit_extraction() {
        <span class="comment">// Length of the data vector we'll be extracting from.
        </span><span class="kw">let </span>len = <span class="number">20</span>;

        <span class="kw">let </span>rng = <span class="kw-2">&amp;mut </span>XorShiftRng::from_seed(TEST_SEED);
        <span class="kw">let </span>data: Vec&lt;u8&gt; = (<span class="number">0</span>..len).map(|<span class="kw">_</span>| rng.gen()).collect();

        <span class="comment">// TODO: Evaluate designing a scattered pattered of `pos` and `num_bits`
        // instead of repeating too many iterations with any number.
        </span><span class="kw">for _ in </span><span class="number">0</span>..<span class="number">100 </span>{
            <span class="kw">let </span>pos = rng.gen_range(<span class="number">0</span>..data.len() / <span class="number">2</span>);
            <span class="kw">let </span>num_bits = rng.gen_range(<span class="number">1</span>..data.len() * <span class="number">8 </span>- pos);
            <span class="kw">let </span>new_offset = rng.gen_range(<span class="number">0</span>..<span class="number">8</span>);

            <span class="kw">let </span><span class="kw-2">mut </span>bv = BitVec::&lt;LittleEndian, u8&gt;::new();
            bv.extend(
                BitVec::&lt;LittleEndian, u8&gt;::from(<span class="kw-2">&amp;</span>data[..])
                    .into_iter()
                    .skip(pos)
                    .take(num_bits),
            );
            <span class="kw">let </span>shifted_bv: BitVec&lt;LittleEndian, u8&gt; = bv &gt;&gt; new_offset;

            <span class="macro">assert_eq!</span>(
                shifted_bv.as_slice(),
                <span class="kw-2">&amp;</span>extract_bits_and_shift(<span class="kw-2">&amp;</span>data, pos, num_bits, new_offset)[..],
            );
        }
    }

    <span class="comment">// Test the `shift_bits` function against the `BitVec&lt;LittleEndian, u8&gt;`
    // implementation of `shr_assign` and `shl_assign`.
    </span><span class="attr">#[test]
    </span><span class="kw">fn </span>test_bit_shifts() {
        <span class="kw">let </span>len = <span class="number">5</span>;
        <span class="kw">let </span>rng = <span class="kw-2">&amp;mut </span>XorShiftRng::from_seed(TEST_SEED);

        <span class="kw">for </span>amount <span class="kw">in </span><span class="number">1</span>..<span class="number">8 </span>{
            <span class="kw">for </span>left <span class="kw">in </span>[<span class="bool-val">true</span>, <span class="bool-val">false</span>].iter() {
                <span class="kw">let </span>data: Vec&lt;u8&gt; = (<span class="number">0</span>..len).map(|<span class="kw">_</span>| rng.gen()).collect();

                <span class="kw">let </span>shifted_bits = shift_bits(<span class="kw-2">&amp;</span>data, amount, <span class="kw-2">*</span>left);

                <span class="kw">let </span><span class="kw-2">mut </span>bv: BitVec&lt;LittleEndian, u8&gt; = data.into();
                <span class="kw">if </span><span class="kw-2">*</span>left {
                    bv &gt;&gt;= amount;
                } <span class="kw">else </span>{
                    bv &lt;&lt;= amount;
                }
                <span class="comment">// We use the opposite shift notation (see `shift_bits`).

                </span><span class="macro">assert_eq!</span>(bv.as_slice(), shifted_bits.as_slice());
            }
        }
    }

    <span class="comment">// Simple (and slow) padder implementation using `BitVec`.
    // It is technically not quite right to use `BitVec` to test
    // `write_padded` since at the moment that function still uses
    // it for some corner cases, but since largely this implementation
    // has been replaced it seems reasonable.
    </span><span class="kw">fn </span>bit_vec_padding(raw_data: Vec&lt;u8&gt;) -&gt; Box&lt;[u8]&gt; {
        <span class="kw">let </span><span class="kw-2">mut </span>padded_data: BitVec&lt;LittleEndian, u8&gt; = BitVec::new();
        <span class="kw">let </span>raw_data: BitVec&lt;LittleEndian, u8&gt; = BitVec::from(raw_data);

        <span class="kw">for </span>data_unit <span class="kw">in </span>raw_data
            .into_iter()
            .chunks(FR32_PADDING_MAP.data_bits)
            .into_iter()
        {
            padded_data.extend(data_unit);

            <span class="comment">// To avoid reconverting the iterator, we deduce if we need the padding
            // by the length of `padded_data`: a full data unit would not leave the
            // padded layout aligned (it would leave it unaligned by just `pad_bits()`).
            </span><span class="kw">if </span>padded_data.len() % <span class="number">8 </span>!= <span class="number">0 </span>{
                <span class="kw">for _ in </span><span class="number">0</span>..FR32_PADDING_MAP.pad_bits() {
                    padded_data.push(<span class="bool-val">false</span>);
                }
            }
        }

        padded_data.into_boxed_slice()
    }

    <span class="comment">// `write_padded` and `write_unpadded` for 1016 bytes of 1s, check the
    // recovered raw data.
    </span><span class="attr">#[test]
    </span><span class="kw">fn </span>test_read_write_padded() {
        <span class="kw">let </span>len = <span class="number">1016</span>; <span class="comment">// Use a multiple of 254.
        </span><span class="kw">let </span>data = <span class="macro">vec!</span>[<span class="number">255u8</span>; len];
        <span class="kw">let </span><span class="kw-2">mut </span>padded = Vec::new();
        <span class="kw">let </span><span class="kw-2">mut </span>reader = Fr32Reader::new(Cursor::new(<span class="kw-2">&amp;</span>data));
        reader
            .read_to_end(<span class="kw-2">&amp;mut </span>padded)
            .expect(<span class="string">"in-memory read failed"</span>);

        <span class="macro">assert_eq!</span>(
            padded.len(),
            FR32_PADDING_MAP.transform_byte_offset(len, <span class="bool-val">true</span>)
        );

        <span class="kw">let </span><span class="kw-2">mut </span>unpadded = Vec::new();
        <span class="kw">let </span>unpadded_written =
            write_unpadded(<span class="kw-2">&amp;</span>padded, <span class="kw-2">&amp;mut </span>unpadded, <span class="number">0</span>, len).expect(<span class="string">"un-padded write failed"</span>);
        <span class="macro">assert_eq!</span>(unpadded_written, len);
        <span class="macro">assert_eq!</span>(data, unpadded);
        <span class="macro">assert_eq!</span>(padded.into_boxed_slice(), bit_vec_padding(data));
    }

    <span class="comment">// `write_padded` and `write_unpadded` for 1016 bytes of random data, recover
    // different lengths of raw data at different offset, check integrity.
    </span><span class="attr">#[test]
    </span><span class="kw">fn </span>test_read_write_padded_offset() {
        <span class="kw">let </span>rng = <span class="kw-2">&amp;mut </span>XorShiftRng::from_seed(TEST_SEED);

        <span class="kw">let </span>len = <span class="number">1016</span>;
        <span class="kw">let </span>data: Vec&lt;u8&gt; = (<span class="number">0</span>..len).map(|<span class="kw">_</span>| rng.gen()).collect();

        <span class="kw">let </span><span class="kw-2">mut </span>padded = Vec::new();
        <span class="kw">let </span><span class="kw-2">mut </span>reader = Fr32Reader::new(Cursor::new(<span class="kw-2">&amp;</span>data));
        reader
            .read_to_end(<span class="kw-2">&amp;mut </span>padded)
            .expect(<span class="string">"in-memory read failed"</span>);

        {
            <span class="kw">let </span><span class="kw-2">mut </span>unpadded = Vec::new();
            write_unpadded(<span class="kw-2">&amp;</span>padded, <span class="kw-2">&amp;mut </span>unpadded, <span class="number">0</span>, <span class="number">1016</span>).expect(<span class="string">"un-padded write failed: 1016"</span>);
            <span class="kw">let </span>expected = <span class="kw-2">&amp;</span>data[<span class="number">0</span>..<span class="number">1016</span>];

            <span class="macro">assert_eq!</span>(expected.len(), unpadded.len());
            <span class="macro">assert_eq!</span>(expected, <span class="kw-2">&amp;</span>unpadded[..]);
        }

        {
            <span class="kw">let </span><span class="kw-2">mut </span>unpadded = Vec::new();
            write_unpadded(<span class="kw-2">&amp;</span>padded, <span class="kw-2">&amp;mut </span>unpadded, <span class="number">0</span>, <span class="number">44</span>).expect(<span class="string">"un-padded write failed: 44"</span>);
            <span class="kw">let </span>expected = <span class="kw-2">&amp;</span>data[<span class="number">0</span>..<span class="number">44</span>];

            <span class="macro">assert_eq!</span>(expected.len(), unpadded.len());
            <span class="macro">assert_eq!</span>(expected, <span class="kw-2">&amp;</span>unpadded[..]);
        }

        <span class="kw">let </span>excessive_len = <span class="number">35</span>;
        <span class="kw">for </span>start <span class="kw">in </span>(<span class="number">1016 </span>- excessive_len + <span class="number">2</span>)..<span class="number">1016 </span>{
            <span class="macro">assert!</span>(write_unpadded(<span class="kw-2">&amp;</span>padded, <span class="kw-2">&amp;mut </span>Vec::new(), start, excessive_len).is_err());
        }
    }

    <span class="comment">// TODO: Add a test that drops the last part of an element and tries to recover
    // the rest of the data (may already be present in some form in the above tests).
</span>}
</code></pre></div></section></main></body></html>