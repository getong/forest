searchState.loadedDescShard("pathfinding", 0, "pathfinding\nDeprecated: moved into the <code>directed</code> module.\nAlgorithms for directed graphs.\nRectangular grid in which vertices can be added or …\nCompute a maximum weight maximum matching between two …\nMatrix of an arbitrary type and utilities to rotate, …\nThe matrix! macro allows the declaration of a Matrix from …\nExport all public functions and structures for an easy …\nAlgorithms for undirected graphs.\nMiscellaneous utilities\nCompute a shortest path (or all shorted paths) using the A*…\nCompute a shortest path using the breadth-first search …\nCount the total number of possible paths to reach a …\nIdentify a cycle in an infinite sequence.\nCompute a path using the depth-first search algorithm.\nCompute a shortest path using the Dijkstra search algorithm…\nCompute the maximum flow that can go through a directed …\nCompute a shortest path using the Fringe search algorithm.\nCompute a shortest path using the IDA* search algorithm.\nCompute a shortest path using the iterative deepening …\nSeparate nodes of a directed graph into strongly connected …\nFind a topological order in a directed graph if one exists.\nCompute k-shortest paths using Yen’s search algorithm.\nIterator structure created by the <code>astar_bag</code> function.\nCompute a shortest path using the A* search algorithm.\nCompute all shortest paths using the A* search algorithm. …\nCompute all shortest paths using the A* search algorithm. …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nStruct returned by <code>bfs_reach</code>.\nCompute a shortest path using the breadth-first search …\nReturn one of the shortest loop from start to start if it …\nVisit all nodes that are reachable from a start node. The …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturn a lower bound on the number of remaining reachable …\nCount the total number of possible paths to reach a …\nIdentify a cycle in an infinite sequence using Brent’s …\nIdentify a cycle in an infinite sequence using Floyd’s …\nStruct returned by <code>dfs_reach</code>.\nCompute a path using the depth-first search algorithm. The …\nVisit all nodes that are reachable from a start node. The …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturn a lower bound on the number of remaining reachable …\nStruct returned by <code>dijkstra_reach</code>.\nInformation about a node reached by <code>dijkstra_reach</code>.\nBuild a path leading to a target according to a parents …\nCompute a shortest path using the Dijkstra search algorithm…\nDetermine all reachable nodes from a starting point as …\nDetermine some reachable nodes from a starting point as …\nVisit all nodes that are reachable from a start node. The …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe node that was reached by <code>dijkstra_reach</code>.\nThe previous node that the current node came from. If the …\nThe total cost from the starting node.\nCommon fields.\nDense capacity and flow data.\nType alias for Edmonds-Karp maximum flow result.\nType alias for representing an edge in a graph\nRepresentation of capacity and flow data.\nSparse capacity and flow data.\nAdd a given flow between two nodes. This should not be used\nAdd some residual capacity.\nCompute the maximum flow and minimum cut.\nCommon data.\nMutable common data.\nCompute the maximum flow and the minimal cut of a directed …\nHelper for the <code>edmonds_karp</code> function using an adjacency …\nHelper for the <code>edmonds_karp</code> function using adjacency maps …\nFlow between two nodes.\nAll flows between nodes.\nAll positive flows starting from a node.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new populated structure.\nCreate a new populated structure.\nAre detailed flows and cuts requested?\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new empty structure.\nDo not request the detailed flows and cuts as a result. …\nResidual capacity between two nodes.\nList of successors with positive residual capacity and …\nSet capacity between two nodes.\nSet total capacity.\nSink.\nNumber of nodes.\nSource.\nGet total capacity.\nCompute a shortest path using the Fringe search algorithm.\nCompute a shortest path using the IDA* search algorithm.\nCompute a shortest path using the iterative deepening …\nCompute the strongly connected component containing a …\nPartition all strongly connected components in a graph.\nPartition nodes reachable from a starting point into …\nFind a topological order in a directed graph if one exists.\nTopologically sort a directed graph into groups of …\nCompute the k-shortest paths using the Yen’s search …\nIterator returned by calling <code>.edges()</code> on a grid.\nRepresentation of a rectangular grid in which vertices can …\nIterator returned by calling <code>.into_iter()</code> on a grid.\nIterator returned by calling <code>.iter()</code> on a grid.\nAdd the borders of the grid. Return the number of added …\nAdd a new vertex. Return <code>true</code> if the vertex did not …\nReturn a set of the indices reachable from a candidate …\nRemove all vertices from the grid. Return <code>true</code> if the grid …\nConstrain a wrapped-around index so that it falls inside …\nReturn a set of the indices reachable from a candidate …\nDisable diagonal mode. Only horizontal and vertical edges …\nDistance between two potential vertices. If diagonal mode …\nIterate over edges.\nEnable diagonal mode. Diagonal edges will be created …\nFill the grid with all possible vertices. Return <code>true</code> if …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nBuild a grid from an arbitrary set of <code>(x, y)</code> coordinates. …\nCheck if an edge is present.\nCheck if a vertex is present.\nThe grid height.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRemove every existing vertex, and add all absent vertices. …\nReturn <code>true</code> if the grid contains no vertices.\nReturn <code>true</code> if no additional vertices can be set (because …\nCheck if a (possibly removed) vertex belongs to the grid …\nIterate over vertices.\nReturn the list of neighbours of a given vertex. If <code>vertex</code> …\nCreate a new empty grid object of the given dimensions, …\nRemove the borders of the grid. Return the number of …\nRemove a vertex. Return <code>true</code> if the vertex did previously …\nResize the grid to the given dimensions. Return <code>true</code> if …\nReturn the number of positions in this grid.\nReturn the number of vertices.\nThe grid width.\nAdjacency matrix for weights.\nReturn the element at position.\nReturn the number of columns.\nCompute a maximum weight maximum matching between two …\nCompute a minimum weight maximum matching between two …\nReturn the negated weights.\nReturn the number of rows.\nColumn iterator returned by <code>column_iter()</code> on a matrix.\nAttempt to build a matrix containing an empty row\nMatrix of an arbitrary type. Data are stored consecutively …\nFormat error encountered while attempting to build a …\nRow iterator returned by <code>iter()</code> on a matrix.\nAttempt to access elements not inside the matrix\nAttempt to build a matrix or a row from data with the …\nReturn a set of the indices reachable from a candidate …\nReturn an iterator on content of columns of the matrix.\nColumns\nConstrain a wrapped-around index so that it falls inside …\nReturn a set of the indices reachable from a candidate …\nDirections usable for <code>Matrix::in_direction()</code> second …\nExtend the matrix in place by adding one full row.\nFill with a known value.\nFlip the matrix around the vertical axis.\nFlip the matrix around the horizontal axis.\nReturn a copy of the matrix flipped along the vertical …\nReturn a copy of the matrix flipped along the horizontal …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate new matrix with each cell’s initial value given …\nCreate a matrix from something convertible to an iterator …\nCreate new matrix from vector values. The first value will …\nAccess an element if the coordinates designate a matrix …\nMutably access an element if the coordinates designate a …\nIndex in raw data of a given position.\nIndex in raw data of a given position.\nReturn an iterator of cells in a given direction starting …\nReturn an iterator on the Matrix indices, first row first. …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the matrix is empty.\nCheck if a matrix is a square one.\nReturn an iterator on the Matrix coordinates and values, …\nReturn an iterator on the Matrix coordinates and mutable …\nReturn an iterator on rows of the matrix.\nReturn an iterator on the Matrix indices, first row first. …\nTransform the matrix into another matrix with the same …\nReturn the next cells in a given direction starting from a …\nReturn an iterator on neighbours of a given matrix cell, …\nCreate new matrix with an initial value.\nCreate new empty matrix with a predefined number of …\nCreate new square matrix with initial value.\nRotate a square matrix counter-clock-wise a number of …\nRotate a square matrix clock-wise a number of times.\nReturn a copy of a matrix rotated counter-clock-wise a …\nReturn a copy of a matrix rotated clock-wise a number of …\nRows\nReplace a slice of the current matrix with the content of …\nReturn a copy of a sub-matrix.\nCreate new square matrix from vector values. The first …\nSwap two elements of the matrix.\nTranspose a matrix in place.\nReturn a copy of the matrix after transposition.\nReturn an iterator on values, first row first.\nReturn a mutable iterator on values, first row first.\nCheck if the coordinates designate a matrix cell.\nFour main directions\nEight main directions with diagonals\nEast\nNorth\nNorth-East\nNorth-West\nSouth\nSouth-East\nSouth-West\nWest\nSeparate components of an undirected graph into disjoint …\nFind minimum-spanning-tree in an undirected graph using …\nLocate vertices amongst disjoint sets.\nSeparate components of an undirected graph into disjoint …\nExtract connected components from a graph.\nSeparate components of an undirected graph into disjoint …\nFind a minimum-spanning-tree. From a collection of …\nMinimal-spanning-tree for nodes with integer indices. The …\nConstrain <code>value</code> into <code>0..upper</code> by adding or subtracting …\nRepeatedly call <code>move_in_direction</code> until the returned value …\nMove a two-dimensional coordinate into a given direction …\nReturn the square root of <code>n</code> if <code>n</code> is square, <code>None</code> otherwise.")