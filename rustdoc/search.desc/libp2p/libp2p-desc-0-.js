searchState.loadedDescShard("libp2p", 0, "libp2p is a modular peer-to-peer networking framework.\nA pending <code>Output</code> for an outbound connection, obtained from …\nAn error that occurred during connection setup.\nPossible error during the handshake.\nPossible error during the handshake.\nFuture that performs the handshake with the remote.\nFuture that performs the handshake with the remote.\nPossible upgrade on an inbound connection or substream.\nA pending <code>Output</code> for an inbound connection, obtained from …\nRepresentation of a Multiaddr.\nThe <code>Multiaddr</code> passed as parameter is not supported.\nAny other error that a <code>Transport</code> may produce.\nPossible upgrade on an outbound connection or substream.\nThe result of a connection setup process, including …\nOutput after the upgrade has been successfully negotiated …\nOutput after the upgrade has been successfully negotiated …\nIdentifier of a peer of the network.\nIdentifies a protocol for a stream.\nContains the state of the network, plus the way it should …\nBuild a <code>Swarm</code> by combining an identity, a set of <code>Transport</code>…\nA transport provides connection-oriented communication …\nAn error during dialing or listening on a <code>Transport</code>.\nTrait automatically implemented on all objects that …\nAdd a <strong>confirmed</strong> external address for the local node.\nAdd a new external address of a remote peer.\nApplies a function producing an asynchronous result to …\nReturns a reference to the provided <code>NetworkBehaviour</code>.\nReturns a mutable reference to the provided …\nBoxes the transport, including custom transport errors.\nEasy way for a user to create a <code>Multiaddr</code>.\nAttempt to gracefully close a connection.\nReturns the currently connected peers.\nDials the given <code>Multiaddr</code>, returning a future for a …\nDial a known or unknown peer.\nDisconnects a peer by its peer ID, closing all connections …\nCreate a new, empty multiaddress.\nChecks whether the given <code>Multiaddr</code> is a suffix of this …\nList all <strong>confirmed</strong> external address for the local node.\nConvert a Multiaddr to a string\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParses a <code>PeerId</code> from bytes.\nTries to turn a <code>Multihash</code> into a <code>PeerId</code>.\nBuilds a <code>PeerId</code> from a public key.\nIgnore this stream in the Swarm’s connection-keep-alive …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks whether there is an established connection to a …\nReturns true if the length of this multiaddress is 0.\nReturns the components of this multiaddress.\nReturn the length in bytes of this multiaddress.\nListens on the given <code>Multiaddr</code> for inbound connections …\nStarts listening on the given address. Returns an error if …\nReturns an iterator that produces the list of addresses we…\nReturns the peer ID of the swarm passed as parameter.\nApplies a function on the connections created by the …\nApplies a function to the error in <code>TransportError::Other</code>.\nApplies a function on the errors generated by the futures …\nReturns information about the connections underlying the …\nCreates a new <code>Swarm</code> from the given <code>Transport</code>, …\nConstruct a new protocol from a static string slice.\nAdds a fallback transport that is used when encountering …\nPoll for <code>TransportEvent</code>s.\nPops the last <code>Protocol</code> of this multiaddr, or <code>None</code> if the …\nReturns &amp;str identifiers for the protocol names themselves.\nAdds an already-parsed address component to the end of …\nGenerates a random peer ID from a cryptographically secure …\nRemove an external address for the local node.\nRemove a listener.\nRemove some listener.\nReplace a <code>Protocol</code> at some position in this <code>Multiaddr</code>.\nReturns a base-58 encoded string of this <code>PeerId</code>.\nReturns a raw bytes representation of this <code>PeerId</code>.\nReturn a copy of this <code>Multiaddr</code>’s byte representation.\nAttempt to construct a protocol from an owned string.\nRust-libp2p Tutorials to get started with.\nBegins a series of protocol upgrades via an …\nAfter we have determined that the remote supports one of …\nAfter we have determined that the remote supports one of …\nLike <code>Multiaddr::push</code> but consumes <code>self</code>.\nAdds a layer on the <code>Transport</code> that logs all traffic that …\nAdds a layer on the <code>Transport</code> that logs all traffic that …\nCreate a new, empty multiaddress with the given capacity.\nAppends the given <code>PeerId</code> if not yet present at the end of …\nAdds a TCP based transport.\nConfigures the SwarmBuilder to use the Tokio runtime. This …\nThe list of explicitly allowed peers.\nA <code>NetworkBehaviour</code> that can act as an allow or block list.\nA connection to this peer was explicitly blocked and was …\nThe list of explicitly blocked peers.\nA connection to this peer is not explicitly allowed and …\nAllow connections to the given peer.\nBlock connections to a given peer.\nDisallow connections to the given peer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUnblock connections to a given peer.\n<code>NetworkBehaviour</code> for AutoNAT.\nConfig for the <code>Behaviour</code>.\nThe connection closed before a response was received.\nThe connection closed before a response could be send.\nThe protocol name used for negotiating with …\nThe request could not be sent because a dialing attempt …\nThe outbound request failed, was rejected, or the remote …\nThe inbound request failed, was rejected, or none of the …\nEvent produced by <code>Behaviour</code>.\nPossible failures occurring in the context of receiving an …\nEvent on an inbound probe.\nInbound probe failed.\nReceiving the dial-back request or sending a response …\nAn IO failure happened on an outbound stream.\nAn IO failure happened on an inbound stream.\nAssumed NAT status.\nProbe was aborted because the local peer has no listening …\nProbe was aborted because no server is known, or all …\nPossible failures occurring in the context of sending an …\nEvent on an outbound probe.\nOutbound probe failed or was aborted.\nSending the dial-back request or receiving a response …\nUnique identifier for a probe.\nA dial-back request was sent to a remote peer.\nA dial-back request was received from a remote peer.\nThe server refused or failed to dial us.\nThe remote successfully dialed one of our addresses.\nWe refused or failed to dial the client.\nA dial request to the remote was successful.\nThe local peer failed to respond to an inbound request due …\nThe assumed NAT changed.\nThe request timed out before a response was received.\nThe inbound request timed out, either while reading the …\nThe remote supports none of the requested protocols.\nThe local peer supports none of the protocols requested by …\nAdd a peer to the list over servers that may be used for …\nDelay on init before starting the fist probe.\nConfidence in the assumed NAT status.\nMax confidence that can be reached in a public / private …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMax addresses that are tried per peer.\nAssumed NAT status.\nAs a server reject probes for clients that are observed at …\nExplicitly probe the provided address for external …\nAssumed public address of the local peer. Returns <code>None</code> in …\nInterval in which the NAT should be tested again if max …\nRemove a peer from the list of servers. See …\nInterval in which the NAT status should be re-tried if it …\nMax total dial requests done in …\nMax dial requests done in <code>[Config::throttle_clients_period</code>]…\nPeriod for throttling clients requests.\nThrottle period for re-using a peer as server for a …\nTimeout for requests.\nUse connected peers as servers for probes.\nImplementation of the AutoNAT protocol.\nThe second version of the autonat protocol.\nNew status.\nFormer status.\nThe addresses that will be attempted to dial.\nPeer that sent the request.\nPeer to which the response is sent.\nPeer that sent the dial-back request.\nThe address at which the remote succeeded to dial us.\nPeer to which the request is sent.\nId of the peer that sent the response.\nId of the peer used for the probe. <code>None</code> if the probe was …\n<code>NetworkBehaviour</code> for AutoNAT.\nConfig for the <code>Behaviour</code>.\nThe connection closed before a response was received.\nThe connection closed before a response could be send.\nThe protocol name used for negotiating with …\nThe request could not be sent because a dialing attempt …\nThe outbound request failed, was rejected, or the remote …\nThe inbound request failed, was rejected, or none of the …\nEvent produced by <code>Behaviour</code>.\nPossible failures occurring in the context of receiving an …\nEvent on an inbound probe.\nInbound probe failed.\nReceiving the dial-back request or sending a response …\nAn IO failure happened on an outbound stream.\nAn IO failure happened on an inbound stream.\nAssumed NAT status.\nProbe was aborted because the local peer has no listening …\nProbe was aborted because no server is known, or all …\nPossible failures occurring in the context of sending an …\nEvent on an outbound probe.\nOutbound probe failed or was aborted.\nSending the dial-back request or receiving a response …\nUnique identifier for a probe.\nA dial-back request was sent to a remote peer.\nA dial-back request was received from a remote peer.\nThe server refused or failed to dial us.\nThe remote successfully dialed one of our addresses.\nWe refused or failed to dial the client.\nA dial request to the remote was successful.\nThe local peer failed to respond to an inbound request due …\nThe assumed NAT changed.\nThe request timed out before a response was received.\nThe inbound request timed out, either while reading the …\nThe remote supports none of the requested protocols.\nThe local peer supports none of the protocols requested by …\nDelay on init before starting the fist probe.\nMax confidence that can be reached in a public / private …\nMax addresses that are tried per peer.\nAs a server reject probes for clients that are observed at …\nInterval in which the NAT should be tested again if max …\nInterval in which the NAT status should be re-tried if it …\nMax total dial requests done in …\nMax dial requests done in <code>[Config::throttle_clients_period</code>]…\nPeriod for throttling clients requests.\nThrottle period for re-using a peer as server for a …\nTimeout for requests.\nUse connected peers as servers for probes.\nNew status.\nFormer status.\nThe addresses that will be attempted to dial.\nPeer that sent the request.\nPeer to which the response is sent.\nPeer that sent the dial-back request.\nThe address at which the remote succeeded to dial us.\nPeer to which the request is sent.\nId of the peer that sent the response.\nId of the peer used for the probe. <code>None</code> if the probe was …\nThe amount of data that was sent to the server. Is 0 if it …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe result of the test. If the test was successful, this …\nThe peer id of the server that was selected for testing.\nThe address that was selected for testing.\nAll address that were submitted for testing.\nThe peer id of the client that submitted addresses for …\nThe amount of data that was requested by the server and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe result of the test.\nThe address that was eventually tested.\nAllows obtaining the average bandwidth of the streams.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the total number of bytes that have been …\nReturns the total number of bytes that have been uploaded …\nA <code>NetworkBehaviour</code> that enforces a set of <code>ConnectionLimits</code>.\nThe configurable connection limits.\nA connection limit has been exceeded.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns a mutable reference to <code>ConnectionLimits</code>.\nConfigures the maximum number of concurrent established …\nConfigures the maximum number of concurrent established …\nConfigures the maximum number of concurrent established …\nConfigures the maximum number of concurrent established …\nConfigures the maximum number of concurrently incoming …\nConfigures the maximum number of concurrently outgoing …\nThe endpoint roles associated with an established …\nA pending <code>Output</code> for an outbound connection, obtained from …\nThe socket comes from a dialer.\nWe dialed the node.\nThe endpoint roles associated with a peer-to-peer …\nError type of the muxer\nAn error that occurred during connection setup.\nPossible error during the handshake.\nPossible error during the handshake.\nFuture that performs the handshake with the remote.\nFuture that performs the handshake with the remote.\nPossible upgrade on an inbound connection or substream.\nOpaque type representing a negotiable protocol.\nIterator returned by <code>protocol_info</code>.\nThe socket comes from a listener.\nWe received the node.\nA pending <code>Output</code> for an inbound connection, obtained from …\nRepresentation of a Multiaddr.\nPossible upgrade on an outbound connection or substream.\nThe result of a connection setup process, including …\nOutput after the upgrade has been successfully negotiated …\nOutput after the upgrade has been successfully negotiated …\nIdentifier of a peer of the network.\nRepresents a peer routing record.\nA signed envelope contains an arbitrary byte string …\nProvides multiplexing for a connection by allowing users …\nType of the object that represents the raw substream where …\nA transport provides connection-oriented communication …\nCommon trait for upgrades that can be applied on inbound …\nApplies a function producing an asynchronous result to …\nBoxes the transport, including custom transport errors.\nDials the given <code>Multiaddr</code>, returning a future for a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDecode a <code>SignedEnvelope</code> using the protobuf encoding …\nAttempt to re-construct a <code>PeerRecord</code> from a <code>SignedEnvelope</code>.\nReturns the address of the remote stored in this struct.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEncode this <code>SignedEnvelope</code> using the protobuf encoding …\nIs this endpoint a dialer?\nReturns true if we are <code>Dialer</code>.\nIs this endpoint a listener?\nReturns true if we are <code>Listener</code>.\nReturns true if the connection is relayed.\nListens on the given <code>Multiaddr</code> for inbound connections …\nApplies a function on the connections created by the …\nApplies a function on the errors generated by the futures …\nMuxing is the process of splitting a connection into …\nConstruct a new <code>PeerRecord</code> by authenticating the provided …\nConstructs a new <code>SignedEnvelope</code>.\nAdds a fallback transport that is used when encountering …\nExtract the payload and signing key of this <code>SignedEnvelope</code>.\nPoll to allow the underlying connection to make progress.\nPoll for <code>TransportEvent</code>s.\nPoll to close this <code>StreamMuxer</code>.\nPoll for new inbound substreams.\nPoll for a new, outbound substream.\nReturns the list of protocols that are supported. Used …\nRemove a listener.\nModifies the address of the remote stored in this struct.\nTurns the <code>ConnectedPoint</code> into the corresponding <code>Endpoint</code>.\nConnection-oriented communication channels.\nContains everything related to upgrading a connection or a …\nBegins a series of protocol upgrades via an …\nAfter we have determined that the remote supports one of …\nAfter we have determined that the remote supports one of …\nVerify this <code>SignedEnvelope</code> against the provided …\nMultiaddress that was successfully dialed.\nLocal connection address.\nWhether the port for the outgoing connection was reused …\nWhether the role of the local node on the connection …\nAddress used to send back data to the remote.\nThe endpoint roles associated with an established …\nThe socket comes from a dialer.\nWe dialed the node.\nThe endpoint roles associated with a peer-to-peer …\nThe socket comes from a listener.\nWe received the node.\nMultiaddress that was successfully dialed.\nLocal connection address.\nWhether the port for the outgoing connection was reused …\nWhether the role of the local node on the connection …\nAddress used to send back data to the remote.\nImplements <code>Future</code> and dispatches all method calls to …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nFailed to parse the URL.\nContains the error value\nError types\nError while parsing an URL.\nSome information in the URL would be lost. Never returned …\nIterator over <code>Multiaddr</code> <code>Protocol</code>s.\nContains the “port” to contact. Similar to TCP or UDP, …\nRepresentation of a Multiaddr.\nContains the success value\nRepresents an Onion v3 address\nIterator over the string idtenfiers of the protocols (not …\n<code>Protocol</code> describes all possible multiaddress protocols.\nThe URL scheme was not recognized.\nConsume this instance and create an owned version …\nTurn this <code>Protocol</code> into one that owns its data, thus being …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParse a single <code>Protocol</code> value from its byte slice …\nParse a protocol value from the given iterator of string …\nAttempts to parse an URL into a multiaddress.\nAttempts to parse an URL into a multiaddress. Ignores …\nReturn the hash of the public key as bytes\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEasy way for a user to create a <code>Multiaddr</code>.\nReturn the port\nEncode this protocol by writing its binary representation …\nContains the error value\nOpaque error struct for operations involving a <code>Multihash</code>.\nA Multihash instance that only supports the basic …\nDeprecated type-alias for the <code>Multihash</code> type.\nContains the success value\nMultihash result.\nReturns the code of the multihash.\nReturns the digest.\nReturns the length in bytes needed to encode this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nParses a multihash from a bytes.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDecomposes struct, useful when needing a <code>Sized</code> array or …\nReads a multihash from a byte stream.\nResizes the backing multihash buffer.\nReturns the size of the digest.\nReturns the bytes of a multihash.\nTruncates the multihash to the given size. It’s up to …\nWraps the digest in a multihash.\nWrites a multihash to a byte stream, returning the written …\nThe address of the remote has changed.\nError type of the muxer\nProvides multiplexing for a connection by allowing users …\nAbstract <code>StreamMuxer</code>.\nAn event produced by a <code>StreamMuxer</code>.\nExtension trait for <code>StreamMuxer</code>.\nType of the object that represents the raw substream where …\nAbstract type for asynchronous reading and writing.\nReturns a future for closing this <code>StreamMuxer</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTurns a stream muxer into a <code>StreamMuxerBox</code>.\nConstruct a new <code>SubstreamBox</code> from something that …\nPoll to allow the underlying connection to make progress.\nPoll to close this <code>StreamMuxer</code>.\nConvenience function for calling <code>StreamMuxer::poll_close</code> …\nPoll for new inbound substreams.\nConvenience function for calling <code>StreamMuxer::poll_inbound</code> …\nPoll for a new, outbound substream.\nConvenience function for calling <code>StreamMuxer::poll_outbound</code>…\nConvenience function for calling <code>StreamMuxer::poll</code> for …\nFailed to extract the payload from the envelope.\nFailed to decode a multi-address.\nFailed to decode the peer ID.\nFailed to decode the provided bytes as a <code>PeerRecord</code>.\nThe signer of the envelope is different than the peer id …\nRepresents a peer routing record.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nErrors that occur whilst decoding a <code>SignedEnvelope</code> from …\nDecoding the provided bytes as a signed envelope failed.\nThe public key in the envelope could not be converted to …\nThe signature on the signed envelope does not verify with …\nThe public key in the envelope could not be converted to …\nErrors that occur whilst extracting the payload of a …\nA signed envelope contains an arbitrary byte string …\nThe payload contained in the envelope is not of the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn address is no longer being listened on.\nA <code>Boxed</code> transport is a <code>Transport</code> whose <code>Dial</code>, <code>Listener</code> and …\nA pending <code>Output</code> for an outbound connection, obtained from …\nOptions to customize the behaviour during dialing.\nAn error that occurred during connection setup.\nA connection is incoming on one of the listeners.\nA listener closed.\nA listener errored.\nThe ID of a single listener.\nA pending <code>Output</code> for an inbound connection, obtained from …\nTransport that supports <code>/memory/N</code> multiaddresses.\nThe <code>Multiaddr</code> passed as parameter is not supported.\nAlways allocate a new port for the dial.\nA new address is being listened on.\nTransport that is possibly disabled.\nStruct returned by <code>or_transport()</code>.\nAny other error that a <code>Transport</code> may produce.\nThe result of a connection setup process, including …\nThe port use policy for a new connection.\nBest effor reusing of an existing port.\nA transport provides connection-oriented communication …\nAn error during dialing or listening on a <code>Transport</code>.\nEvent produced by <code>Transport</code>s.\nA custom upgrade on an <code>Authenticated</code> transport.\nApplies a function producing an asynchronous result to …\nBoxes the transport, including custom transport errors.\nDials the given <code>Multiaddr</code>, returning a future for a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTry to turn this transport event into the expire <code>Multiaddr</code>.\nTry to turn this transport event into the upgrade parts of …\nTry to turn this transport event into the listener error.\nTry to turn this transport event into the new <code>Multiaddr</code>.\nReturns <code>true</code> if this is an <code>TransportEvent::AddressExpired</code>.\nReturns <code>true</code> if this is an <code>TransportEvent::ListenerError</code> …\nReturns <code>true</code> if this is a <code>TransportEvent::NewAddress</code>.\nReturns <code>true</code> if this is an <code>Incoming</code> transport event.\nListens on the given <code>Multiaddr</code> for inbound connections …\nApplies a function on the connections created by the …\nApplies a function on the errors generated by the futures …\nIn case this <code>TransportEvent</code> is an <code>ListenerError</code>, or …\nIn case this <code>TransportEvent</code> is an upgrade, apply the given …\nCreates a new <code>ListenerId</code>.\nBuilds a disabled <code>OptionalTransport</code>.\nAdds a fallback transport that is used when encountering …\nPoll for <code>TransportEvent</code>s.\nThe port use policy for a new connection.\nRemove a listener.\nThe endpoint establishing a new connection.\nBuilds an <code>OptionalTransport</code> with the given transport in an …\nTransports with timeouts on the connection setup.\nConfiguration of transport protocol upgrades.\nBegins a series of protocol upgrades via an …\nThe error value.\nThe new address that is being listened on.\nThe new address that is being listened on.\nThe listener that is listening on the new address.\nThe listener that is no longer listening on the address.\nThe listener that produced the upgrade.\nThe ID of the listener that closed.\nThe ID of the listener that errored.\nLocal connection address.\nReason for the closure. Contains <code>Ok(())</code> if the stream …\nAddress used to send back data to the incoming client.\nThe produced upgrade.\nSee the <code>Transport::and_then</code> method.\nCustom <code>Future</code> to avoid boxing.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStruct returned by <code>or_transport()</code>.\nImplementation of <code>AsyncRead</code> and <code>AsyncWrite</code>. Not meant to …\nImplementation of <code>Transport</code> that doesn’t support any …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBuilds a new <code>DummyTransport</code>.\nDropping all dial requests to non-global IP addresses.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSee <code>Transport::map</code>.\nCustom <code>Future</code> to avoid boxing.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSee <code>Transport::map_err</code>.\nDialing future for <code>MapErr</code>.\nListening upgrade future for <code>MapErr</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTries to listen on a port that is already in use.\nA channel represents an established, in-memory, logical …\nA channel represents an established, in-memory, logical …\nConnection to a <code>MemoryTransport</code> currently being opened.\nListener for memory connections.\nTransport that supports <code>/memory/N</code> multiaddresses.\nError that can be produced from the <code>MemoryTransport</code>.\nThere’s no listener on the given port.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOther kind of error.\nWraps around a <code>Future</code>. Turns the error type from …\nThe transport timed out.\nAn error happened in the timer.\nA <code>TransportTimeout</code> is a <code>Transport</code> that wraps another …\nError that can be produced by the <code>TransportTimeout</code> layer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWraps around a <code>Transport</code> to add timeouts to all the …\nWraps around a <code>Transport</code> to add timeouts to the ingoing …\nWraps around a <code>Transport</code> to add timeouts to the outgoing …\nAn upgrade that authenticates the remote peer, typically …\nAn transport with peer authentication, obtained from …\nA <code>Builder</code> facilitates upgrading of a <code>Transport</code> for use with\nThe <code>Transport::Dial</code> future of an <code>Upgrade</code>d transport.\nThe <code>Transport::ListenerUpgrade</code> future of an <code>Upgrade</code>d …\nAn upgrade that negotiates a (sub)stream multiplexer on …\nA authenticated and multiplexed transport, obtained from …\nError in the transport.\nErrors produced by a transport upgrade.\nA custom upgrade on an <code>Authenticated</code> transport.\nError while upgrading to a protocol.\nVersion 1 of the multistream-select protocol. See 1 and 2.\nA “lazy” variant of version 1 that is identical on the …\nSupported multistream-select versions.\nApplies an arbitrary upgrade.\nUpgrades the transport to perform authentication of the …\nBoxes the authenticated, multiplexed transport, including …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAdds a timeout to the setup and protocol upgrade process …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUpgrades the transport with a (sub)stream multiplexer.\nLike <code>Authenticated::multiplex</code> but accepts a function which …\nCreates a <code>Builder</code> over the given (base) <code>Transport</code>.\nAdds a timeout to the setup and protocol upgrade process …\nAdds a timeout to the setup and protocol upgrade process …\nDummy implementation of <code>UpgradeInfo</code>/<code>InboundUpgrade</code>/…\nPossible error during the handshake.\nPossible error during the handshake.\nPossible error during the handshake.\nPossible error during the handshake.\nProtocol negotiation failed because no protocol could be …\nFuture that performs the handshake with the remote.\nFuture that performs the handshake with the remote.\nFuture that performs the handshake with the remote.\nFuture that performs the handshake with the remote.\nPossible upgrade on an inbound connection\nPossible upgrade on an inbound connection or substream.\nOpaque type representing a negotiable protocol.\nIterator returned by <code>protocol_info</code>.\nReceived an invalid message from the remote.\nA protocol (name) is invalid.\nI/O error.\nA <code>Future</code> that waits on the completion of protocol …\nError that can happen when negotiating a protocol with the …\nPossible upgrade on an outbound connection\nPossible upgrade on an outbound connection or substream.\nOutput after the upgrade has been successfully negotiated …\nOutput after the upgrade has been successfully negotiated …\nOutput after the upgrade has been successfully negotiated …\nOutput after the upgrade has been successfully negotiated …\nImplementation of <code>UpgradeInfo</code>, <code>InboundUpgrade</code> and …\nA protocol error.\nA protocol error occurred during the negotiation.\nImplementation of <code>UpgradeInfo</code>, <code>InboundUpgrade</code> and …\nUpgrade that combines two upgrades into one. Supports all …\nToo many protocols have been returned by the remote.\nCommon trait for upgrades that can be applied on inbound …\nVersion 1 of the multistream-select protocol. See 1 and 2.\nA “lazy” variant of version 1 that is identical on the …\nSupported multistream-select versions.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCombines two upgrades into an <code>SelectUpgrade</code>.\nReturns the list of protocols that are supported. Used …\nAfter we have determined that the remote supports one of …\nAfter we have determined that the remote supports one of …\nAfter we have determined that the remote supports one of …\nAfter we have determined that the remote supports one of …\nThe possible errors of a <code>Transport</code> wrapped transport.\nAn error got returned from IO\nAn error with an arbitrary message, referenced as &amp;’…\nAn error with an arbitrary message, stored as String\nDNS resolution was successful, but the underlying …\nNo resolvers available\nNo records were found for a query\nAn error got returned by the hickory-proto crate\nThe error type for errors that get returned in the crate\nDNS resolution failed.\nThe error kind for errors that get returned in the crate\nConfiguration for the upstream nameservers to use for …\nConfiguration for the Resolver\nA request timed out\nDNS resolution involved too many lookups.\nA <code>Transport</code> for performing DNS lookups when dialing …\nThe underlying transport encountered an error.\nAdd the configuration for a name server\nAdd a search domain\nNumber of retries after lookup failure before giving up. …\nThis is true by default, disabling this is useful for …\nCache size is in number of records (some records can be …\nValidate the names in the response, not implemented don’…\nCreates a default configuration, using <code>1.1.1.1</code>, <code>1.0.0.1</code> …\nCreates a <code>Transport</code> with a custom resolver configuration …\nCreates a default configuration, using <code>8.8.8.8</code>, <code>8.8.4.4</code> …\nDefault values for the Resolver configuration.\nReturns the local domain\nEnable edns, for larger records\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a ResolverConfig with all parts specified\nA conversion to determine if the response is an error\nCreates a default configuration, using <code>8.8.8.8</code>, <code>8.8.4.4</code> …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe ip_strategy for the Resolver to use when lookup Ipv4 …\nGet the kind of the error\nReturns a reference to the name servers\nSets the number of dots that must appear (unless it’s a …\nOptional maximum TTL for negative (<code>NXDOMAIN</code>) responses.\nOptional minimum TTL for negative (<code>NXDOMAIN</code>) responses.\nCreates a new empty configuration\nNumber of concurrent requests per query\nOptional maximum TTL for positive responses.\nOptional minimum TTL for positive responses.\nPreserve all intermediate records in the lookup response, …\nCreates a configuration, using <code>9.9.9.9</code>, <code>149.112.112.112</code> …\nRequest upstream recursive resolvers to not perform any …\nRotate through the resource records in the response (if …\nReturns the search domains\nThe server ordering strategy that the resolver should use.\nSet the domain of the entity querying results.\nShuffle DNS servers before each query.\nCreates a new <code>Transport</code> from the OS’s DNS configuration …\nSpecify the timeout for a request. Defaults to 5 seconds\nTry queries over TCP if they fail over UDP.\nCheck /ect/hosts file before dns requery (only works for …\nUse DNSSEC to validate the request\nnegative ttl, as determined from DnsResponse::negative_ttl …\nThe query for which no records were found.\nResponseCode, if <code>NXDOMAIN</code>, the domain does not exist (and …\nIf an SOA is present, then this is an authoritative …\nIf we trust <code>NXDOMAIN</code> errors from this server\nA <code>Transport</code> wrapper for performing DNS lookups when …\nThe message is considered valid, and it should be …\nAllows all subscriptions\nMessage signing is disabled.\nThis setting requires the author, sequence number and …\nMessage signing is disabled.\nNetwork behaviour that handles the gossipsub protocol.\nCombines two subscription filters\nConfiguration parameters that define the performance of …\nThe builder struct for constructing a gossipsub …\nError associated with Config building.\nA general trait of transforming a <code>RawMessage</code> into a <code>Message</code>…\nThis message has already been published.\nThe sequence number was empty, expected a value.\nEvent that can be emitted by the gossipsub behaviour.\nA peer that does not support gossipsub has connected.\nA generic trait that can be extended for various hashing …\nHistory length less than history gossip length.\nThe default transform, the raw data is propagated as is to …\nThe message is neither delivered nor forwarded to the …\nThere were no peers to send this message to.\nThe PeerId was invalid\nInvalid protocol\nThe sequence number was the incorrect size\nThe message has an invalid signature,\nAdds a max count to a given subscription filter\nMaximum transmission size is too small.\nThe inequality doesn’t hold mesh_outbound_min &lt;= …\nThe ineauality doesn’t hold mesh_outbound_min &lt;= …\nThe message sent to the user after a <code>RawMessage</code> has been …\nA message has been received.\nValidation kinds from the application for received …\nDetermines if published messages should be signed or not.\nMessage source existed when validation has been sent to …\nThe overall message was too large. This could be due to …\nThis setting does not check the author, sequence number or …\nWe are not allowed to subscribe to this topic by the …\nThis setting permits messages that have no author, …\nError associated with publishing a gossipsub message.\nCouldn’t publish our subscription\nMessage signing is disabled.\nA message received by the gossipsub system and stored …\nA subscription filter that filters topics based on a …\nThe message is considered invalid, and it should be …\nSequence number existed when validation has been sent to …\nSignature existed when validation has been sent to …\nMessage signing is enabled. The author will be the owner …\nAn error occurred whilst signing the message.\nThis is the default setting. This requires the message …\nA remote subscribed to a topic.\nError associated with subscribing to a topic.\nA gossipsub topic.\nThe compression algorithm failed.\nThe data transformation failed.\nunsubscribe_backoff is zero\nA remote unsubscribed from a topic.\nThe types of message validation that can be employed by …\nSelector for custom Protocol Id\nAllows only whitelisted subscriptions\nThe score threshold below which px will be ignored; this …\nAdds a new peer to the list of explicitly connected peers.\nLists all known peers and their associated subscribed …\nReturns true iff we allow an incoming subscription. This …\nBy default, gossipsub will reject messages that are sent …\nBy default, gossipsub will reject messages that are sent …\nP5: Application-specific peer scoring\nNumber of heartbeat slots considered as slack for …\nNumber of heartbeat slots considered as slack for …\nP7: behavioural pattern penalties. This parameter has an …\nBlacklists a peer. All messages from this peer will be …\nCreate buckets for the score histograms based on score …\nConstructs a <code>Config</code> from the given configuration and …\nReturns true iff the topic is of interest and we can …\nThe number of heartbeat ticks until we recheck the …\nThe number of heartbeat ticks until we recheck the …\nContent of the message. Its meaning is out of scope of …\nContent of the message.\nThe decay interval for parameter counters.\nCounter value below which it is considered 0.\nEnables Peer eXchange. This should be enabled in …\nWhether Peer eXchange is enabled; this should be enabled …\nDuplicates are prevented by storing message id’s of …\nDuplicates are prevented by storing message id’s of …\nTime to live for fanout peers (default is 60 seconds).\nTime to live for fanout peers (default is 60 seconds).\nFilters a set of deduplicated subscriptions By default …\nFilters a list of incoming subscriptions and returns a …\nP2: first message deliveries This is the number of message …\nWhether to do flood publishing or not. If enabled newly …\nWhether to do flood publishing or not. If enabled newly …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a scoring parameters for a topic if existent.\nAffects how many peers we will emit gossip to at each …\nAffects how many peers we will emit gossip to at each …\nMinimum number of peers to emit gossip to during a …\nMinimum number of peers to emit gossip to during a …\nControls how many times we will allow a peer to request …\nControls how many times we will allow a peer to request …\nThe score threshold below which gossip propagation is …\nIf a GRAFT comes before <code>graft_flood_threshold</code> has elapsed …\nIf a GRAFT comes before <code>graft_flood_threshold</code> has elapsed …\nThe score threshold below which message processing is …\nThe function that takes a topic string and creates a topic …\nInitial delay in each heartbeat (default is 5 seconds).\nInitial delay in each heartbeat (default is 5 seconds).\nTime between each heartbeat (default is 1 second).\nTime between each heartbeat (default is 1 second).\nNumber of past heartbeats to gossip about (default is 3).\nNumber of past heartbeats to gossip about (default is 3).\nNumber of heartbeats to keep in the <code>memcache</code> (default is …\nNumber of heartbeats to keep in the <code>memcache</code> (default is …\nTakes a <code>RawMessage</code> received and converts it to a <code>Message</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nP4: invalid messages This is the number of invalid …\nP6: IP-colocation factor. The parameter has an associated …\nReturns true if signing is enabled.\nTime to wait for a message requested through IWANT …\nTime to wait for a message requested through IWANT …\nThe public key of the message if it is signed and the …\nThe maximum number of messages to include in an IHAVE …\nThe maximum number of messages to include in an IHAVE …\nGossipSubMaxIHaveMessages is the maximum number of IHAVE …\nGossipSubMaxIHaveMessages is the maximum number of IHAVE …\nThe maximum number of messages we will process in a given …\nThe maximum number of messages we will process in a given …\nMesh topics are controlled by the user via subscriptions …\nThis provides an upper bound to the number of mesh topics …\nThe maximum byte size for each gossip (default is 2048 …\nThe maximum byte size for each gossipsub RPC (default is …\nP3b: sticky mesh propagation failures This is a sticky …\nP3: mesh message deliveries This is the number of message …\nTarget number of peers for the mesh network (D in the …\nTarget number of peers for the mesh network (D in the …\nMaximum number of peers in mesh network before removing …\nMaximum number of peers in mesh network before removing …\nMinimum number of peers in mesh network before adding more …\nMinimum number of peers in mesh network before adding more …\nMinimum number of outbound peers in the mesh network …\nMinimum number of outbound peers in the mesh network …\nLists all mesh peers for a certain topic hash.\nA user-defined function allowing the user to specify the …\nA user-defined function allowing the user to specify the …\nCreates a Gossipsub <code>Behaviour</code> struct given a set of …\nCreates a Gossipsub <code>Behaviour</code> struct given a set of …\nCreates a Gossipsub <code>Behaviour</code> struct given a set of …\nCreates a Gossipsub <code>Behaviour</code> struct given a set of …\nCreates a Gossipsub <code>Behaviour</code> struct given a set of …\nThe maximum number of new peers to graft to during …\nThe maximum number of new peers to graft to during …\nThe median mesh score threshold before triggering …\nNumber of heartbeat ticks that specify the interval in …\nNumber of heartbeat ticks that specify the interval in …\nTakes the data to be published (a topic and associated …\nLists all known peers and their associated protocol.\nReturns the gossipsub score for a given peer, if one …\nThe full protocol id to negotiate this protocol (does not …\nThe protocol id prefix to negotiate this protocol (default …\nControls the backoff time for pruned peers. This is how …\nControls the backoff time for pruned peers. This is how …\nControls the number of peers to include in prune Peer …\nControls the number of peers to include in prune Peer …\nPublishes a message with multiple topics to the network.\nThe score threshold below which we shouldn’t publish …\nPublished message ids time cache duration. The default is …\nPublished message ids time cache duration. The default is …\nCalculates the encoded length of this message (used for …\nRemoves a peer from the blacklist if it has previously …\nThis removes the peer from explicitly connected peers, …\nThis function should be called when …\nTime to remember counters for a disconnected peer.\nAffects how peers are selected when pruning a mesh due to …\nAffects how peers are selected when pruning a mesh due to …\nBuckets used for the score histograms.\nComputes the decay factor for a parameter, assuming the …\nComputes the decay factor for a parameter using base as …\nA random sequence number.\nA random sequence number.\nSets the application specific score for a peer. Returns …\nSets scoring parameters for a topic.\nThe signature of the message if it’s signed.\nId of the peer that published this message.\nId of the peer that published this message.\nSubscribe to a topic.\nEnable support for flooodsub peers.\nEnable support for flooodsub peers. Default false.\nP1: time in the mesh This is the time the peer has been …\nThe topic this message belongs to\nThe topic this message belongs to\nAggregate topic score cap; this limits the total …\nThe weight of the topic.\nLists the hashes of the topics we are currently subscribed …\nScore parameters per topic.\nUnsubscribes from a topic.\nControls the backoff time when unsubscribing from a topic.\nControls the backoff time when unsubscribing from a topic.\nWhen set, prevents automatic forwarding of all received …\nWhen set to <code>true</code>, prevents automatic forwarding of all …\nFlag indicating if this message has been validated by the …\nDetermines the level of validation used when receiving …\nDetermines the level of validation used when receiving …\nActivates the peer scoring system with the given …\nActivates the peer scoring system with the given …\nThe decompressed message itself.\nThe <code>MessageId</code> of the message. This should be referenced by …\nRemote that has subscribed.\nRemote that has unsubscribed.\nThe peer that forwarded us this message.\nThe topic it has subscribed to.\nThe topic it has subscribed from.\nNetwork behaviour that automatically identifies nodes …\nConfiguration for the <code>identify::Behaviour</code>.\nError while attempting to identify the remote.\nEvent emitted  by the <code>Identify</code> behaviour.\nIdentify information of a peer sent in protocol messages.\nIdentification information of the local node has been …\nIdentification information has been received from a peer.\nIdentification information of the local node has been sent …\nName and version of the local peer implementation, similar …\nName and version of the peer, similar to the <code>User-Agent</code> …\nHow many entries of discovered peers to keep before we …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe interval at which identification requests are sent to …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe addresses that the peer is listening on.\nThe public key of the local node. To report on the wire.\nCreates a new identify <code>Behaviour</code>.\nCreates a new configuration for the identify <code>Behaviour</code> that\nAddress observed by or for the remote.\nApplication-specific version of the protocol family used …\nApplication-specific version of the protocol family used …\nThe list of protocols supported by the peer, e.g. …\nThe public key of the local peer.\nInitiates an active push of the local peer information to …\nWhether new or expired listen addresses of the local node …\nConfigures the agent version sent to peers.\nConfigures the size of the LRU cache, caching addresses of …\nConfigures the interval at which identification requests …\nConfigures whether new or expired listen addresses of the …\nIdentifier of the connection.\nIdentifier of the connection.\nIdentifier of the connection.\nIdentifier of the connection.\nThe error that occurred.\nThe information provided by the peer.\nThe full Info struct we pushed to the remote peer. Clients …\nThe peer that has been identified.\nThe peer that the information has been sent to.\nThe peer that the information has been sent to.\nThe peer with whom the error originated.\nThe <code>α</code> parameter of the Kademlia specification.\nA peer sent an add provider request. If filtering …\nA (repeated) query initiated by <code>Behaviour::start_providing</code>.\nThe query advertises the local node as a provider for the …\nThe context of a <code>QueryInfo::AddProvider</code> query.\nThe possible errors when publishing a provider record.\nThe successful result of publishing a provider record.\nThe phases of a <code>QueryInfo::AddProvider</code> query.\nThe result of publishing a provider record.\nA non-empty list of (unique) addresses of a peer in the …\n<code>Behaviour</code> is a <code>NetworkBehaviour</code> that implements the libp2p …\nThe result of <code>Behaviour::bootstrap</code>.\nA query initiated by <code>Behaviour::bootstrap</code>.\nThe error result of <code>Behaviour::bootstrap</code>.\nThe successful result of <code>Behaviour::bootstrap</code>.\nThe result of <code>Behaviour::bootstrap</code>.\nThe configurable strategies for the insertion of peers and …\nThe configuration for Kademlia “write-back” caching …\nSender was recently connected to peer.\nSender tried to connect to peer but failed.\nThe configuration for the <code>Kademlia</code> behaviour.\nThe node is considered connected.\nSender is currently connected to peer.\nStatus of our connection to a node reported by the …\nThe context is a custom store operation targeting specific …\nCaching is disabled and the peers closest to records being …\nThe node is considered disconnected.\nUp to <code>max_peers</code> peers not returning a record that are …\nA cloned, immutable view of an entry that is either …\nContains the error value\nContains the error value\nContains the error value\nContains the error value\nContains the error value\nContains the error value\nThe events produced by the <code>Kademlia</code> behaviour.\nThe routing table update failed, either because the …\nWhenever a (provider) record is received, an event is …\nRequest for the list of nodes whose IDs are the closest to …\nThe result of <code>Behaviour::get_closest_peers</code>.\nA (repeated) query initiated by …\nThe query is searching for the closest nodes to the record …\nThe query is searching for the closest nodes to the record …\nThe error result of <code>Behaviour::get_closest_peers</code>.\nThe successful result of <code>Behaviour::get_closest_peers</code>.\nThe result of <code>Behaviour::get_closest_peers</code>.\nSame as <code>FindNode</code>, but should also return the entries of …\nThe result of <code>Behaviour::get_providers</code>.\nA (repeated) query initiated by <code>Behaviour::get_providers</code>.\nThe error result of <code>Behaviour::get_providers</code>.\nThe successful result of <code>Behaviour::get_providers</code>.\nThe result of <code>Behaviour::get_providers</code>.\nRequest to retrieve a record.\nThe result of <code>Behaviour::get_record</code>.\nA (repeated) query initiated by <code>Behaviour::get_record</code>.\nThe error result of <code>Behaviour::get_record</code>.\nThe successful result of <code>Behaviour::get_record</code>.\nThe result of <code>Behaviour::get_record</code>.\nInformation about a received and handled inbound request.\nAn inbound request has been received and handled.\nA distance between two keys in the DHT keyspace.\nA <code>Key</code> in the DHT keyspace with preserved preimage.\nA reference to a bucket.\nThe <code>k</code> parameter of the Kademlia specification.\nNew peers and addresses are only added to the routing …\nThis peer’s mode has been updated automatically.\nAn operation failed to due no known peers in the routing …\nThe status of a node in a bucket.\nSender hasn’t tried to connect to peer.\nContains the success value\nContains the success value\nContains the success value\nContains the success value\nContains the success value\nContains the success value\nWhenever a connection to a peer is established as a result …\nAn outbound query has made progress.\nPeer Info combines a Peer ID with a set of multiaddrs that …\nA record either received by the given peer or retrieved …\nThe peer and address is pending insertion into the routing …\nA connection to a peer has been established for whom a …\nInformation about progress events.\nA record stored in the DHT whose value is the ID of a peer …\nThe context is a <code>Behaviour::start_providing</code> operation.\nThe context is a <code>Behaviour::put_record</code> operation.\nA peer sent a put record request. If filtering …\nThe result of <code>Behaviour::put_record</code>.\nA (repeated) query initiated by <code>Behaviour::put_record</code>.\nThe query is replicating the record to the closest nodes …\nThe context of a <code>QueryInfo::PutRecord</code> query.\nThe error result of <code>Behaviour::put_record</code>.\nThe successful result of <code>Behaviour::put_record</code>.\nThe phases of a <code>QueryInfo::PutRecord</code> query.\nThe result of <code>Behaviour::put_record</code>.\nUnique identifier for an active query.\nInformation about a running query.\nA mutable reference to a running query.\nAn immutable reference to a running query.\nThe results of Kademlia queries.\nExecution statistics of a query.\nA quorum w.r.t. the configured replication factor …\nA record stored in the DHT.\nThe (opaque) key of a record.\nThe context is periodic replication (i.e. without extending\nThe context is periodic republishing of provider …\nThe context is periodic republishing of records stored …\nThe result of a (automatic) republishing of a provider …\nThe result of a (automatic) republishing of a …\nA connection to a peer has been established for whom a …\nThe possible outcomes of <code>Behaviour::add_address</code>.\nThe routing table has been updated with a new peer and / or\nThe result of <code>Behaviour::start_providing</code>.\nThe configurable filtering strategies for the acceptance of\nThe given peer and address has been added to the routing …\nWhenever a (provider) record is received, the record is …\nA peer has connected for whom no listen address is known.\nAdds a known listen address of a peer participating in the …\nThe known addresses that the provider may be listening on.\nBootstraps the local node to join the DHT.\nTests whether the given distance falls into this bucket.\nThe index into the event\nReturns the default configuration.\nReturns the default configuration.\nRequire iterative queries to use disjoint paths for …\nComputes the distance of the keys according to the XOR …\nGets the duration of the query.\nThe expiration time as measured by a local, monotonic …\nThe expiration time as measured by a local, monotonic …\nFinishes the query asap, without waiting for the regular …\nGets a reference to the first address in the list.\nReturns the uniquely determined key with the given …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns closest peers to the given key; takes peers from …\nInitiates an iterative query for the closest peers to the …\nPerforms a lookup for providers of a value to the given …\nPerforms a lookup for a record in the DHT.\nReturns true if the bucket has a pending node.\nExposing the hashed bytes.\nReturns the integer part of the base 2 logarithm of the …\nGets information about the type and state of the query.\nGets information about the type and state of the query.\nAdds a new address to the end of the list.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nExtracts the key of the record for which the operation …\nExtracts the key of the record for which the operation …\nExtracts the key for which the operation failed, consuming …\nExtracts the key for which the operation failed, consuming …\nExtracts the key for which the operation failed,\nConverts the key into its preimage.\nConverts the addresses into a <code>Vec</code>.\nChecks whether the bucket is empty.\nChecks whether the record is expired w.r.t. the given …\nChecks whether the provider record is expired w.r.t. the …\nReturns an iterator over the entries in the bucket.\nReturns an iterator over the addresses.\nGets an iterator over immutable references to all running …\nGets an iterator over mutable references to all running …\nReturns the k-bucket for the distance to the given key.\nReturns an iterator over all non-empty buckets in the …\nGets the key of the record for which the operation failed.\nGets the key of the record for which the operation failed.\nGets the key for which the operation failed.\nGets the key for which the operation failed.\nGets the key for which the operation failed.\nKey of the record.\nThe key whose value is provided by the provider.\nIs this the final event?\nReturns the number of addresses in the list.\nMerges these stats with the given stats of another query, …\nCreates a new <code>Kademlia</code> network behaviour with a default …\nCreates a new list of addresses.\nBuilds a new <code>Config</code> with the given protocol name.\nConstructs a new <code>Key</code> by running the given value through a …\nCreates a new key from the bytes of the input.\nCreates a new record for insertion into the DHT.\nCreates a new provider record for insertion into a …\nThe node represented by the entry.\nReturns the number of entries in the bucket.\nGets the number of failed requests.\nGets the number of pending requests.\nGets the total number of requests initiated by the query.\nGets the number of successful requests.\nThe peer from whom the record was received. <code>None</code> if the …\nBorrows the preimage of the key.\nGet the protocol name of this kademlia instance.\nThe provider of the value for the key.\nThe (original) publisher of the record.\nStores a record in the DHT, locally as well as at the nodes\nStores a record at specific peers, without storing it …\nGets an immutable reference to a running query, if it …\nGets a mutable reference to a running query, if it exists.\nGenerates a random distance that falls into this bucket.\nReturns the minimum inclusive and maximum inclusive …\nRemoves the given address from the list.\nRemoves an address of a peer from the routing table.\nRemoves a peer from the routing table.\nRemoves the record with the given key from <em>local</em> storage, …\nReplaces an old address with a new address.\nSets the <code>Caching</code> strategy to use for successful lookups.\nSets the k-bucket insertion strategy for the Kademlia …\nSets the timeout duration after creation of a pending …\nSets the configuration for the k-buckets.\nModifies the maximum allowed size of individual Kademlia …\nSet the <code>Mode</code> in which we should operate.\nSets the allowed level of parallelism for iterative …\nSets the interval on which <code>Behaviour::bootstrap</code> is called …\nSets custom protocol names.\nSets the interval at which provider records for keys …\nSets the TTL for provider records.\nSets the (re-)publication interval of stored records.\nSets the timeout for a single query.\nSets whether or not records should be filtered before …\nSets the TTL for stored records.\nSets the replication factor to use.\nSets the (re-)replication interval for stored records.\nEstablishes the local node as a provider of a value for …\nGets execution statistics about the query.\nGets execution statistics about the query.\nThe status of the node.\nStops the local node from announcing that it is a provider …\nGets a mutable reference to the record store.\nCopies the bytes of the key into a new vector.\nValue of the record.\nCreates a new <code>Kademlia</code> network behaviour with the given …\nThe external addresses of the provider being advertised.\nQuery statistics from the finished <code>GetClosestPeers</code> phase.\nThe local peer ID that is advertised as a provider.\nThe full list of known addresses of <code>peer</code>.\nReturns the minimum inclusive and maximum inclusive …\nThe ID of the query that finished.\nWhether this is a new peer and was thus just added to the …\nThe ID of the peer that was evicted from the routing table …\nThe ID of the peer that was added or updated.\nThe intermediate result of the query.\nExecution statistics from the query.\nIndicates which event this is, if therer are multiple …\nThe new set of providers discovered.\nIf caching is enabled, these are the peers closest <em>to the </em>…\n<code>PeerId</code>s of the peers the record was successfully stored on.\n<code>PeerId</code>s of the peers the record was successfully stored on.\nQuery statistics from the finished <code>GetClosestPeers</code> phase.\nA list of peers the given record has been successfully …\nThe peers closest to the <code>key</code> that were queried but did not …\nThe execution context of the query.\nThe execution context of the query.\nDid we find at least one record?\nThe key being queried (the preimage).\nThe key for which to search for providers.\nThe record key.\nThe key to look for.\nThe targeted peer ID.\nThe current phase of the query.\nThe current phase of the query.\nThe number of providers found so far.\nThe expected quorum of responses w.r.t. the replication …\nThe remaining random peer IDs to query, one per bucket …\nCurrent index of events.\nCurrent index of events.\nCurrent index of events.\nContains the error value\nThe possible errors of a <code>RecordStore</code> operation.\nThe store is at capacity w.r.t. the total number of stored …\nThe store is at capacity w.r.t. the total number of stored …\nIn-memory implementation of a <code>RecordStore</code>.\nConfiguration for a <code>MemoryStore</code>.\nContains the success value\nTrait for types implementing a record store.\nThe result of an operation on a <code>RecordStore</code>.\nThe store cannot store this value because it is too large.\nAdds a provider record to the store.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets a record from the store, given its key.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe maximum number of provider records for which the local …\nThe maximum number of providers stored for a key.\nThe maximum number of records.\nThe maximum size of record values, in bytes.\nCreates a new <code>MemoryRecordStore</code> with a default …\nGets an iterator over all stored provider records for …\nGets a copy of the stored provider records for the given …\nPuts a record into the store.\nGets an iterator over all (value-) records currently …\nRemoves the record with the given key from the store.\nRemoves a provider record from the store.\nRetains the records satisfying a predicate.\nCreates a new <code>MemoryRecordStore</code> with the given …\nA <code>NetworkBehaviour</code> for mDNS. Automatically discovers peers …\nConfiguration for mDNS.\nDiscovered nodes through mDNS.\nEvent that can be produced by the <code>Mdns</code> behaviour.\nThe given combinations of <code>PeerId</code> and <code>Multiaddr</code> have …\nReturns the list of nodes that we have discovered through …\nUse IPv6 instead of IPv4.\nExpires a node before the ttl.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns true if the given <code>PeerId</code> is in the list of nodes …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBuilds a new <code>Mdns</code> behaviour.\nInterval at which to poll the network for new peers. This …\nThe type of a <code>Behaviour</code> using the <code>tokio</code> implementation.\nTTL to use for mdns records.\nSet of Swarm and protocol metrics derived from emitted …\nRecorder that can record Swarm and protocol events.\nA metric registry.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new set of Swarm and protocol <code>Metrics</code>.\nRecord the given event.\nRegister a metric with the <code>Registry</code>.\nRegister a <code>Collector</code>.\nRegister a metric with the <code>Registry</code> specifying the metric…\nLike <code>Registry::sub_registry_with_prefix</code> but with a label …\nLike <code>Registry::sub_registry_with_prefix</code> but with multiple …\nCreate a sub-registry to register metrics with a common …\nCreates a new default <code>Registry</code> with the given labels.\nCreates a new default <code>Registry</code> with the given prefix.\nCreates a new default <code>Registry</code> with the given prefix and …\nFailed to parse the URL.\nContains the error value\nError types\nError while parsing an URL.\nSome information in the URL would be lost. Never returned …\nIterator over <code>Multiaddr</code> <code>Protocol</code>s.\nContains the “port” to contact. Similar to TCP or UDP, …\nRepresentation of a Multiaddr.\nContains the success value\nRepresents an Onion v3 address\nIterator over the string idtenfiers of the protocols (not …\n<code>Protocol</code> describes all possible multiaddress protocols.\nThe URL scheme was not recognized.\nAttempts to parse an URL into a multiaddress.\nAttempts to parse an URL into a multiaddress. Ignores …\nEasy way for a user to create a <code>Multiaddr</code>.\nContains the error value\nOpaque error struct for operations involving a <code>Multihash</code>.\nA Multihash instance that only supports the basic …\nDeprecated type-alias for the <code>Multihash</code> type.\nContains the success value\nMultihash result.\nContains the error value\nOpaque error struct for operations involving a <code>Multihash</code>.\nA Multihash instance that only supports the basic …\nDeprecated type-alias for the <code>Multihash</code> type.\nContains the success value\nMultihash result.\nThe configuration for the noise handshake.\nlibp2p_noise error type.\nA noise session to a remote.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a new configuration for the noise handshake …\nSet the noise prologue.\nSet WebTransport certhashes extension.\nA <code>NetworkBehaviour</code> that responds to inbound pings and …\nThe configuration for outbound pings.\nEvent generated by the <code>Ping</code> network behaviour.\nAn outbound ping failure.\nThe ping failed for reasons other than a timeout.\nThe ping timed out, i.e. no response was received within …\nThe peer does not support the ping protocol.\nThe connection the ping was executed on.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new <code>Ping</code> network behaviour with the given …\nCreates a new <code>Config</code> with the following default settings:\nThe peer ID of the remote.\nThe result of an inbound or outbound ping.\nSets the ping interval.\nSets the ping timeout.\nA request/response protocol for some message codec.\nA <code>Codec</code> defines the request and response types for a …\nThe configuration for a <code>Behaviour</code> protocol.\nThe connection closed before a response was received.\nThe connection closed before a response could be send.\nThe request could not be sent because a dialing attempt …\nThe events emitted by a request-response <code>Behaviour</code>.\nThe protocol is supported for inbound and outbound …\nThe protocol is only supported for inbound requests.\nPossible failures occurring in the context of receiving an …\nAn inbound request failed.\nThe ID of an inbound request.\nAn IO failure happened on an outbound stream.\nAn IO failure happened on an inbound stream.\nAn inbound request or response.\nAn incoming message (request or response).\nThe protocol is only supported for outbound requests.\nPossible failures occurring in the context of sending an …\nAn outbound request failed.\nThe ID of an outbound request.\nThe type of protocol(s) or protocol versions being …\nThe level of support for a particular protocol.\nA request message.\nThe type of inbound and outbound requests.\nA response message.\nThe type of inbound and outbound responses.\nA channel for sending a response to an inbound request.\nThe local peer failed to respond to an inbound request due …\nA response to an inbound request has been sent.\nThe request timed out before a response was received.\nThe inbound request timed out, either while reading the …\nThe remote supports none of the requested protocols.\nThe local peer supports none of the protocols requested by …\nAdds a known address for a peer that can be used for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWhether inbound requests are supported.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks whether a peer is currently connected.\nChecks whether the response channel is still open, i.e. …\nChecks whether an inbound request from the peer with the …\nChecks whether an outbound request to the peer with the …\nCreates a new <code>Behaviour</code> for the given protocols and …\nWhether outbound requests are supported.\nReads a request from the given I/O stream according to the …\nReads a response from the given I/O stream according to the\nRemoves an address of a peer previously added via …\nInitiates sending a request.\nInitiates sending a response to an inbound request.\nSets the timeout for inbound and outbound requests.\nCreates a new <code>Behaviour</code> for the given protocols, codec and …\nSets the upper bound for the number of concurrent inbound …\nSets the timeout for inbound and outbound requests.\nWrites a request to the given I/O stream according to the …\nWrites a response to the given I/O stream according to the …\nThe error that occurred.\nThe error that occurred.\nThe incoming message.\nThe peer who sent the message.\nThe peer to whom the request was sent.\nThe peer from whom the request was received.\nThe peer to whom the response was sent.\nThe (local) ID of the failed request.\nThe ID of the failed inbound request.\nThe ID of the inbound request whose response was sent.\nThe channel waiting for the response.\nThe request message.\nThe ID of this request.\nThe ID of the request that produced this response.\nThe response message.\nPending connection attempt has been aborted.\nPending connection attempt has been aborted.\n<code>FromSwarm</code> variant that informs the behaviour that the …\nInforms the behaviour that the <code>ConnectedPoint</code> of an …\nDisconnect all connections.\nNotify an arbitrary connection handler.\nThe upgrade produced an error.\nEvent generated by the <code>NetworkBehaviour</code>.\nThe options which connections to close.\nInstructs the <code>Swarm</code> to initiate a graceful close of one or …\n<code>FromSwarm</code> variant that informs the behaviour about a …\nInforms the behaviour about a closed connection to a peer.\nA connection with the given peer has been closed, possibly …\nNetwork connection information.\nA connection was denied.\nErrors that can occur in the context of an established …\nInforms the behaviour about a newly established connection …\nA connection to the given peer has been opened.\nA handler for a set of protocols used on a connection with …\nHandler for all the protocols the network behaviour …\nEvent produced by a handler.\nImplementation of <code>ConnectionHandler</code> that combines two …\nConnection identifier.\nOne of the <code>NetworkBehaviour</code>s rejected the outbound …\nInstructs the swarm to start a dial.\nPossible errors when trying to establish or upgrade an …\n<code>FromSwarm</code> variant that informs the behaviour that the dial …\nInforms the behaviour that the dial to a known or unknown …\nThe provided <code>dial_opts::PeerCondition</code> evaluated to false …\nA new dialing attempt has been initiated by the …\nImplemented on objects that can run a <code>Future</code> in the …\n<code>FromSwarm</code> variant that informs the behaviour that a …\nInforms the behaviour that a multiaddr we were listening …\nOne of our listeners has reported the expiration of a …\nIndicates to the <code>Swarm</code> that the provided address is …\nInforms the behaviour that an external address of the …\nAn external address of the local node was confirmed.\n<code>FromSwarm</code> variant that informs the behaviour that an …\nIndicates to the <code>Swarm</code> that we are no longer externally …\nInforms the behaviour that an external address of the …\nAn external address of the local node expired, i.e. is …\nUtility struct for tracking the external addresses of a …\nA type representing the message(s) a <code>NetworkBehaviour</code> can …\nEnumeration with the list of the possible events to pass …\nInstructs the <code>Swarm</code> to return an event when it is being …\nAn I/O error occurred on the connection.\nThe type of additional information returned from …\nThe inbound upgrade for the protocol(s) used by the …\nA new connection arrived on a listener and is in the …\nAn error happened on an inbound connection during its …\nAn IO or otherwise unrecoverable error happened.\nThe connection keep-alive timeout expired.\nUtility struct for tracking the addresses a <code>Swarm</code> is …\nPossible errors when upgrading an inbound connection.\n<code>FromSwarm</code> variant that informs the behaviour that an error …\nInforms the behaviour that an error happened on an …\nInstructs the <code>Swarm</code> to listen on the provided address.\n<code>FromSwarm</code> variant that informs the behaviour that a …\nInforms the behaviour that a listener closed.\nOne of the listeners gracefully closed.\n<code>FromSwarm</code> variant that informs the behaviour that a …\nInforms the behaviour that a listener experienced an error.\nOne of the listeners reported a non-fatal error.\nThe peer identity obtained on the connection matches the …\nThe connection was dropped because it resolved to our own …\nNo protocol could be agreed upon.\nA <code>NetworkBehaviour</code> defines the behaviour of the local node …\nGenerates a delegating <code>NetworkBehaviour</code> implementation for …\nInformation about the connections obtained by …\n<code>FromSwarm</code> variant that informs the behaviour about a new …\nReports a <strong>new</strong> candidate for an external address to the …\nInforms the behaviour that we have discovered a new …\nWe have discovered a new candidate for an external address …\n<code>FromSwarm</code> variant that informs the behaviour that a new …\nReports external address of a remote peer to the <code>Swarm</code> and …\nInforms the behaviour that we have discovered a new …\nWe have discovered a new address of a peer.\n<code>FromSwarm</code> variant that informs the behaviour that we have …\nInforms the behaviour that we have started listening on a …\nOne of our listeners has reported a new local listening …\nInforms the behaviour that a new listener was created.\nNo addresses have been provided by …\nEvent that is sent to a <code>NetworkBehaviour</code>.\nThe options w.r.t. which connection handler to notify of …\nInstructs the <code>Swarm</code> to send an event to the handler …\nNotify a particular connection handler.\nDisconnect a particular connection.\nA <code>ConnectionHandler</code> that opens a new substream for each …\nConfiguration parameters for the <code>OneShotHandler</code>\nThe type of additional information passed to an …\nThe outbound upgrade for the protocol(s) used by the …\nRequest a new outbound substream to be opened with the …\nAn error happened on an outbound connection.\nStruct for tracking peers’ external addresses of the …\nInstructs the <code>Swarm</code> to remove the listener.\nWe learned something about the protocols supported by the …\nIdentifies a protocol for a stream.\nError that can happen on an outbound substream opening …\nConfiguration of inbound or outbound substream protocol(s) …\nContains the state of the network, plus the way it should …\nEvent generated by the <code>Swarm</code>.\n<code>ConnectionHandler</code> of the <code>NetworkBehaviour</code> for all the …\nCustom event that can be received by the <code>ConnectionHandler</code> …\nCustom event that can be produced by the <code>ConnectionHandler</code> …\nThe opening attempt timed out before the negotiation was …\nA type representing message(s) a <code>ConnectionHandler</code> can …\nA command issued from a <code>NetworkBehaviour</code> for the <code>Swarm</code>.\nEvent generated by the <code>NetworkBehaviour</code> and that the swarm …\nAn error occurred while negotiating the transport …\nAn error occurred while negotiating the transport …\nThe peer identity obtained on the connection did not match …\nThe peer identity obtained on the connection did not match …\nAdds address to cache. Appends address to the existing set …\nGet the <code>Multiaddr</code> that is being listened on\nGets counters for ongoing network connections.\nReturns whether the connection should be kept alive.\nAttempt to downcast to a particular reason for why the …\nAttempt to downcast to a particular reason for why the …\nRun the given future in the background until it ends.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns peer’s external addresses.\nCallback that is invoked for every established inbound …\nCallback that is invoked for every established outbound …\nCallback that is invoked for every new inbound connection.\nCallback that is invoked for every outbound connection …\nOnce a connection to a remote peer is established, a …\nBorrows the contained protocol info.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the substream protocol configuration into the …\nReturns an <code>Iterator</code> over all external addresses.\nReturns an <code>Iterator</code> over all listen addresses.\nThe <code>InboundUpgrade</code> to apply on inbound substreams to …\nReturns a mutable reference to the listen protocol …\nReturns a reference to the listen protocol configuration.\nGet the <code>ListenerId</code> of this listen attempt\nIf this is a <code>Custom</code> event, maps the content to something …\nMap the handler event.\nAdds a closure that turns the input event into something …\nMaps a function over the protocol info.\nMap the event the swarm will return.\nAdds a closure that turns the output event into something …\nIf this is an <code>OutboundSubstreamRequest</code>, maps the <code>info</code> …\nIf this is an <code>OutboundSubstreamRequest</code>, maps the protocol (…\nMaps a function over the protocol upgrade.\nMap the inner <code>StreamUpgradeError</code> type.\nMaximum number of concurrent outbound substreams being …\nCreates a <code>OneShotHandler</code>.\nCreates a <code>PeerAddresses</code> cache with capacity for the given …\nCreate a new <code>SubstreamProtocol</code> from the given upgrade.\nCreates an <em>unchecked</em> <code>ConnectionId</code>.\nThe total number of connections, both pending and …\nThe total number of established connections.\nThe number of established incoming connections.\nThe number of established outgoing connections.\nThe number of connected peers, i.e. peers with whom at …\nThe total number of pending connections, both incoming and …\nThe number of incoming connections being established.\nThe number of outgoing connections being established.\nInforms the handler about an event from the …\nInforms the behaviour about an event generated by the …\nInforms the behaviour about an event from the <code>Swarm</code>.\nFeed a <code>FromSwarm</code> event to this struct.\nFeed a <code>FromSwarm</code> event to this struct.\nFeed a <code>FromSwarm</code> event to this struct.\nTimeout for outbound substream upgrades.\nReturns the number of pending requests.\nPolls for things that swarm should do.\nShould behave like <code>Stream::poll()</code>.\nGracefully close the <code>ConnectionHandler</code>.\nRemoves address from peer addresses cache. Returns true if …\nCreates a new <code>ConnectionHandler</code> that selects either this …\nOpens an outbound substream with <code>upgrade</code>.\nBorrows the timeout for the protocol upgrade.\nExtract the <code>TBehaviourOutEvent</code> from this <code>SwarmEvent</code> in …\nBorrows the contained protocol upgrade.\nNumber of addresses concurrently dialed for a single …\nCreates a new <code>Config</code> from the given executor. The <code>Swarm</code> is …\nHow long to keep a connection alive once it is idling.\nThe maximum number of inbound streams concurrently …\nConfigures the number of events from the <code>NetworkBehaviour</code> …\nConfigures the size of the buffer for events sent by a …\nConfigures an override for the substream upgrade protocol …\nSets a new timeout for the protocol upgrade.\nBuilds a new <code>Config</code> from the given <code>tokio</code> executor.\nThe protocol(s) to apply on the substream.\nThe new address that is being listened on.\nThe expired address.\nThe addresses that the listener was listening on. These …\nReason for the disconnection, if it was not a successful …\n<code>Some</code> when the new connection is an outgoing connection. …\nIdentifier of the connection.\nIdentifier of the connection.\nIdentifier of the connection.\nIdentifier of the connection.\nIdentifier of the connection.\nIdentifier of the connection.\nEndpoint of the connection that has been opened.\nEndpoint of the connection that has been closed.\nThe error that happened.\nError that has been encountered.\nThe listener error.\nHow long it took to establish this connection\nThe listener that is listening on the new address.\nThe listener that is no longer listening on the address.\nThe listener that closed.\nThe listener that errored.\nLocal connection address. This address has been earlier …\nLocal connection address. This address has been earlier …\nNumber of established connections to this peer, including …\nNumber of other remaining connections to this same peer.\nIdentity of the peer that we have connected to.\nIdentity of the peer that we have connected to.\nIf known, <code>PeerId</code> of the peer we tried to reach.\nIdentity of the peer that we are connecting to.\nReason for the closure. Contains <code>Ok(())</code> if the stream …\nAddress used to send back data to the remote.\nAddress used to send back data to the remote.\nWhether to close a specific or all connections to the …\nThe event to send.\nThe options w.r.t. which connection handler to notify of …\nThe peer for whom a <code>ConnectionHandler</code> should be notified.\nThe peer to disconnect.\n<code>FromSwarm</code> variant that informs the behaviour that the …\nInforms the behaviour that the <code>ConnectedPoint</code> of an …\nDisconnect all connections.\nNotify an arbitrary connection handler.\nThe options which connections to close.\nInstructs the <code>Swarm</code> to initiate a graceful close of one or …\n<code>FromSwarm</code> variant that informs the behaviour about a …\nInforms the behaviour about a closed connection to a peer.\n<code>FromSwarm</code> variant that informs the behaviour about a newly …\nInforms the behaviour about a newly established connection …\nHandler for all the protocols the network behaviour …\nInstructs the swarm to start a dial.\n<code>FromSwarm</code> variant that informs the behaviour that the dial …\nInforms the behaviour that the dial to a known or unknown …\n<code>FromSwarm</code> variant that informs the behaviour that a …\nInforms the behaviour that a multiaddr we were listening …\n<code>FromSwarm</code> variant that informs the behaviour that an …\nIndicates to the <code>Swarm</code> that the provided address is …\nInforms the behaviour that an external address of the …\n<code>FromSwarm</code> variant that informs the behaviour that an …\nIndicates to the <code>Swarm</code> that we are no longer externally …\nInforms the behaviour that an external address of the …\nUtility struct for tracking the external addresses of a …\nEnumeration with the list of the possible events to pass …\nInstructs the <code>Swarm</code> to return an event when it is being …\nUtility struct for tracking the addresses a <code>Swarm</code> is …\n<code>FromSwarm</code> variant that informs the behaviour that an error …\nInforms the behaviour that an error happened on an …\nInstructs the <code>Swarm</code> to listen on the provided address.\n<code>FromSwarm</code> variant that informs the behaviour that a …\nInforms the behaviour that a listener closed.\n<code>FromSwarm</code> variant that informs the behaviour that a …\nInforms the behaviour that a listener experienced an error.\nA <code>NetworkBehaviour</code> defines the behaviour of the local node …\n<code>FromSwarm</code> variant that informs the behaviour about a new …\nReports a <strong>new</strong> candidate for an external address to the …\nInforms the behaviour that we have discovered a new …\n<code>FromSwarm</code> variant that informs the behaviour that a new …\nReports external address of a remote peer to the <code>Swarm</code> and …\nInforms the behaviour that we have discovered a new …\n<code>FromSwarm</code> variant that informs the behaviour that we have …\nInforms the behaviour that we have started listening on a …\n<code>FromSwarm</code> variant that informs the behaviour that a new …\nInforms the behaviour that a new listener was created.\nThe options w.r.t. which connection handler to notify of …\nInstructs the <code>Swarm</code> to send an event to the handler …\nNotify a particular connection handler.\nDisconnect a particular connection.\nStruct for tracking peers’ external addresses of the …\nInstructs the <code>Swarm</code> to remove the listener.\nA command issued from a <code>NetworkBehaviour</code> for the <code>Swarm</code>.\nEvent generated by the <code>NetworkBehaviour</code> and that the swarm …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCallback that is invoked for every established inbound …\nCallback that is invoked for every established outbound …\nCallback that is invoked for every new inbound connection.\nCallback that is invoked for every outbound connection …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInforms the behaviour about an event generated by the …\nInforms the behaviour about an event from the <code>Swarm</code>.\nPolls for things that swarm should do.\nWhether to close a specific or all connections to the …\nThe event to send.\nThe options w.r.t. which connection handler to notify of …\nThe peer for whom a <code>ConnectionHandler</code> should be notified.\nThe peer to disconnect.\nImplementation of <code>NetworkBehaviour</code> that can be either in …\nImplementation of <code>ConnectionHandler</code> that can be in the …\nReturns a mutable reference to the inner <code>NetworkBehaviour</code>.\nReturns a reference to the inner <code>NetworkBehaviour</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if <code>Toggle</code> is enabled and <code>false</code> if it’s …\nA new dialing attempt is always initiated, only subject to …\nOptions to configure a dial to a known or unknown peer.\nA new dialing attempt is initiated <em>only if</em> the peer is …\nA combination of <code>Disconnected</code> and <code>NotDialing</code>. A new …\nA new dialing attempt is initiated <em>only if</em> there is …\nThe available conditions under which a new dialing attempt …\nSpecify a single address to dial the unknown peer.\nSpecify a set of addresses to be used to dial the known …\nEnforce the allocation of a new port. Default behaviour is …\nEnforce the allocation of a new port. Default behaviour is …\nEnforce the allocation of a new port. Default behaviour is …\nBuild the final <code>DialOpts</code>.\nBuild the final <code>DialOpts</code>.\nBuild the final <code>DialOpts</code>.\nSpecify a <code>PeerCondition</code> for the dial.\nSpecify a <code>PeerCondition</code> for the dial.\nGet the <code>ConnectionId</code> of this dial attempt.\nIn addition to the provided addresses, extend the set via …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRetrieves the <code>PeerId</code> from the <code>DialOpts</code> if specified or …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOverride Number of addresses concurrently dialed for a …\nOverride Number of addresses concurrently dialed for a …\nOverride role of local node on connection. I.e. execute …\nOverride role of local node on connection. I.e. execute …\nOverride role of local node on connection. I.e. execute …\nDial a known peer.\nDial an unknown peer.\nImplementation of <code>NetworkBehaviour</code> that doesn’t do …\nAn implementation of <code>ConnectionHandler</code> that neither …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe remote now supports these additional protocols.\n<code>ConnectionEvent</code> variant that informs the handler about a …\nInforms the handler about a change in the address of the …\nThe upgrade produced an error.\nEnumeration with the list of the possible stream events to …\nA handler for a set of protocols used on a connection with …\nEvent produced by a handler.\nImplementation of <code>ConnectionHandler</code> that combines two …\n<code>ConnectionEvent</code> variant that informs the handler that …\nInforms the handler that upgrading an outbound substream …\nEquivalent to <code>OutboundUpgrade::Error</code>.\nEquivalent to <code>InboundUpgrade::Error</code>.\nA type representing the message(s) a <code>NetworkBehaviour</code> can …\n<code>ConnectionEvent</code> variant that informs the handler about the …\nInforms the handler about the output of a successful …\n<code>ConnectionEvent</code> variant that informs the handler about …\nInforms the handler about the output of a successful …\nEquivalent to <code>OutboundUpgrade::Future</code>.\nEquivalent to <code>InboundUpgrade::Future</code>.\nThe type of additional information returned from …\nThe inbound upgrade for the protocol(s) used by the …\nImplemented automatically on all types that implement …\nEquivalent to <code>UpgradeInfo::Info</code>.\nEquivalent to <code>UpgradeInfo::InfoIter</code>.\nAn IO or otherwise unrecoverable error happened.\n<code>ConnectionEvent</code> variant that informs the handler that …\nInforms the handler that upgrading an inbound substream to …\nThe local <code>ConnectionHandler</code> added or removed support for …\nWrapper around a protocol handler that turns the input …\nWrapper around a protocol handler that turns the output …\nNo protocol could be agreed upon.\nEvent that is sent to a <code>NetworkBehaviour</code>.\nA <code>ConnectionHandler</code> that opens a new substream for each …\nConfiguration parameters for the <code>OneShotHandler</code>\nThe type of additional information passed to an …\nThe outbound upgrade for the protocol(s) used by the …\nRequest a new outbound substream to be opened with the …\nImplemented automatically on all types that implement …\nEquivalent to <code>OutboundUpgrade::Output</code>.\nEquivalent to <code>InboundUpgrade::Output</code>.\nImplementation of <code>ConnectionHandler</code> that returns a pending …\nAn <code>Iterator</code> over all protocols that have been added.\n<code>ConnectionEvent</code> variant that informs the handler about a …\nAn <code>Iterator</code> over all protocols that have been removed.\nThe remote <code>ConnectionHandler</code> now supports a different set …\nThe remote no longer supports these protocols.\nWe learned something about the protocols supported by the …\nWraps around a type that implements <code>OutboundUpgradeSend</code>, …\nError that can happen on an outbound substream opening …\nConfiguration of inbound or outbound substream protocol(s) …\nThe opening attempt timed out before the negotiation was …\nA type representing message(s) a <code>ConnectionHandler</code> can …\nImplemented automatically on all types that implement …\nReturns whether the connection should be kept alive.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether the event concerns an inbound stream.\nWhether the event concerns an outbound stream.\nThe <code>InboundUpgrade</code> to apply on inbound substreams to …\nAdds a closure that turns the input event into something …\nAdds a closure that turns the output event into something …\nMaximum number of concurrent outbound substreams being …\nA <code>ConnectionHandler</code> implementation that combines multiple …\nInforms the handler about an event from the …\nTimeout for outbound substream upgrades.\nShould behave like <code>Stream::poll()</code>.\nGracefully close the <code>ConnectionHandler</code>.\nEquivalent to <code>UpgradeInfo::protocol_info</code>.\nCreates a new <code>ConnectionHandler</code> that selects either this …\nEquivalent to <code>InboundUpgrade::upgrade_inbound</code>.\nEquivalent to <code>OutboundUpgrade::upgrade_outbound</code>.\nThe protocol(s) to apply on the substream.\nIt is an error if two handlers share the same protocol …\nIndex and protocol name pair used as <code>UpgradeInfo::Info</code>.\nThe aggregated <code>InboundOpenInfo</code>s of supported inbound …\nA <code>ConnectionHandler</code> for multiple <code>ConnectionHandler</code>s of the …\nInbound and outbound upgrade for all <code>ConnectionHandler</code>s.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe protocol name bytes that occurred in more than one …\nCreate and populate a <code>MultiHandler</code> from the given handler …\nThe configuration for a TCP/IP transport capability for …\nAn abstract <code>libp2p_core::Transport</code> implementation.\nCreates a <code>Transport</code> with reasonable defaults.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConfigures the listen backlog for new listen sockets.\nCreate a new instance of <code>Transport</code>.\nCreates a new configuration for a TCP/IP transport:\nConfigures the <code>TCP_NODELAY</code> option for new sockets.\nPoll all listeners.\nConfigures port reuse for local sockets, which implies …\nConfigures the <code>IP_TTL</code> option for new sockets.\nA <code>tokio::net::TcpStream</code> that implements <code>AsyncRead</code> and …\nA TCP <code>Transport</code> that works with the <code>tokio</code> ecosystem.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nHole Punching Tutorial\nPing Tutorial - Getting started with rust-libp2p\nThe event produced by <code>Behaviour</code>.\nThe renewal of the multiaddress on the gateway failed.\nThe IGD gateway was not found.\nThe multiaddress is reachable externally.\nThe Gateway is not exposed directly to the public network.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA <code>NetworkBehaviour</code> for UPnP port mapping. Automatically …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe yamux configuration.\nThe Yamux <code>StreamMuxer</code> error type.\nA Yamux connection.\nA stream produced by the yamux multiplexer.\nThe window update mode determines when window updates are …\nCreates a new <code>YamuxConfig</code> in client mode, regardless of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe window update mode whereby the remote is given new …\nThe window update mode whereby the remote is given new …\nCreates a new <code>YamuxConfig</code> in server mode, regardless of …\nSets the maximum size (in bytes) of the receive buffer per …\nSets the maximum number of concurrent substreams.\nSets the size (in bytes) of the receive window per …\nSets the window update mode that determines when the remote")