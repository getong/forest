searchState.loadedDescShard("quinn", 0, "QUIC transport protocol implementation\nFuture produced by <code>Endpoint::accept</code>\nFuture produced by <code>Connection::accept_bi</code>\nFuture produced by <code>Connection::accept_uni</code>\nParameters for controlling the peer’s acknowledgement …\nReason given by an application for closing the connection\nThe peer closed the connection\nAbstract implementation of an async timer for runtime …\nAbstract implementation of a UDP socket for runtime …\nA chunk of data from the receive stream\nThe connection could not be created because not enough of …\nThe connection could not be created because not enough of …\nConfiguration for outgoing connections\nError indicating that a stream has not been opened or has …\nThe stream has already been stopped, finished, or reset\nThe stream has already been finished or reset\nErrors in the configuration of an endpoint\nErrors in the parameters being used to create a new …\nIn-progress connection attempt future\nA QUIC connection.\nReason given by the transport for closing the connection\nThe peer’s QUIC stack aborted the connection …\nReasons why a connection might be lost\nThe connection was lost\nThe connection was lost\nThe connection was lost\nThe connection was lost\nDatagram support is disabled locally\nA QUIC endpoint.\nGlobal configuration for the endpoint, affecting all …\nThe endpoint can no longer create new connections\nThe stream finished before all bytes were read\nMaximum duration of inactivity to accept before timing out …\nAttempted an ordered read following an unordered read\nAn incoming connection for which the server has not yet …\nBasic adapter to let <code>Incoming</code> be <code>await</code>-ed like a <code>Connecting</code>\nThe remote <code>SocketAddr</code> supplied was malformed\nThe given server name was malformed\nThe local application closed the connection\nThe largest representable value\nThe largest encoded value length\nParameters governing MTU discovery.\nNo default client configuration was set up\nFuture produced by <code>Connection::open_bi</code>\nFuture produced by <code>Connection::open_uni</code>\nValue exceeds supported bounds\nAn error occurred during reading\nFuture produced by <code>Connection::read_datagram</code>\nErrors that arise from reading from a stream.\nA read error occurred\nErrors that arise from reading from a stream.\nErrors from <code>RecvStream::read_to_end</code>\nA stream that can only be used to receive data\nThe peer abandoned transmitting data on this stream\nThe peer is unable to continue processing this connection, …\nError for attempting to retry an <code>Incoming</code> which already …\nAbstracts I/O and timer operations for runtime independence\nErrors that can arise when sending a datagram\nA stream that can only be used to send data\nParameters governing incoming connections\nThe peer is no longer accepting data on this stream\nErrors that arise while monitoring for a send stream stop …\nIdentifier for a stream within a particular connection\nCommunication with the peer has lapsed for longer than the …\nA Quinn runtime for Tokio\nThe datagram is larger than the connection can currently …\nThe stream is larger than the user-supplied limit\nAn outgoing packet\nParameters governing the core QUIC state machine\nThe peer violated the QUIC specification as understood by …\nAn object polled to detect when an associated …\nThe peer does not support receiving datagram frames\nThe local endpoint does not support the QUIC version …\nAn integer less than 2^62\nThe peer doesn’t implement any supported version\nErrors that arise from writing to a stream\nFuture that completes when a connection is fully …\nThis was a 0-RTT stream and the server rejected it\nThis was a 0-RTT stream and the server rejected it\nThis was a 0-RTT stream and the server rejected it\nGet the next incoming connection attempt from a client\nAttempt to accept this incoming connection (an error may …\nAccept the next incoming bidirectional stream\nAccept the next incoming uni-directional stream\nAccept this incoming connection using a custom …\nThe ack-eliciting threshold we will request the peer to use\nSpecifies the ACK frequency config (see <code>AckFrequencyConfig</code> …\nWhether the implementation is permitted to set the spin …\nSpecifies the amount of time that MTU discovery should …\nThe contents of the chunk\nSupply a custom connection ID generator factory\nClose the connection immediately.\nClose all of this endpoint’s connections immediately and …\nIf the connection is closed, the reason why.\nWait for the connection to be closed for any reason\nLogic for controlling the rate at which data is sent\nHow to construct new <code>congestion::Controller</code>s\nCurrent state of the congestion control algorithm, for …\nConnect to a remote endpoint\nConnect to a remote endpoint using a custom configuration.\nCreate a <code>UdpPoller</code> that can register a single task for …\nTraits and implementations for the QUIC cryptography …\nTLS configuration used for incoming connections.\nMaximum quantity of out-of-order crypto layer data to …\nMaximum number of incoming application datagram bytes to …\nMaximum number of outgoing application datagram bytes to …\nBytes available in the outgoing datagram buffer\nAutomatically select an appropriate runtime from those …\nThe socket this datagram should be sent to\nWhich directions data flows in\nExplicit congestion notification bits to set on the packet\nWhether to use “Generic Segmentation Offload” to …\nClass of error as encoded in the specification\nApplication-specific reason code\nDerive keying material from this connection’s TLS …\nNotify the peer that no more data will ever be written to …\nType of frame that caused the close\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a <code>VarInt</code> infallibly\nSucceeds iff <code>x</code> &lt; 2^62\nCreate a VarInt without ensuring it’s in range\nWhether to accept QUIC packets containing any value for …\nParameters negotiated during the handshake\nParameters negotiated during the handshake\nGet the identity of this stream\nGet the identity of this stream\nIgnore this incoming connection attempt, not sending any …\nMaximum number of received bytes to buffer for each …\nMaximum number of received bytes to buffer for all <code>Incoming</code>\nDistinguishes streams of the same initiator and …\nThe initial value to be used as the maximum UDP payload …\nThe RTT used before an RTT sample is taken\nWhich side of a connection initiated the stream\nSpecifies the time to wait after completing MTU discovery …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert into a 0-RTT or 0.5-RTT connection at the cost of …\nGet the <code>Incoming</code>\nExtract the integer value\nCheck if this stream has been opened during 0-RTT.\nPeriod of inactivity before sending a keep-alive packet\nLook up the local IP address and port used by this socket\nGet the local <code>SocketAddr</code> the underlying socket is bound to\nThe local IP address which was used when the peer …\nThe local IP address which was used when the peer …\nThe local IP address which was used when the peer …\nThe <code>max_ack_delay</code> we will request the peer to use\nMaximum number of incoming bidirectional streams that may …\nVariant of <code>max_concurrent_bidi_streams</code> affecting …\nCompute the maximum size of datagrams that may be passed …\nMaximum duration of inactivity to accept before timing out …\nMaximum number of <code>Incoming</code> to allow to exist at a time\nMaximum number of datagrams that might be described by a …\nMaximum number of datagrams that might be described by a …\nMaximum number of datagrams that a <code>Transmit</code> may encode\nMaximum number of datagrams that a <code>Transmit</code> may encode\nMaximum UDP payload size accepted from peers (excluding …\nWhether datagrams might get fragmented into multiple parts\nWhether datagrams might get fragmented into multiple parts\nWhether to allow clients to migrate to new addresses\nThe maximum UDP payload size guaranteed to be supported by …\nMinimum interval between outgoing stateless reset packets\nSpecifies the minimum MTU change to stop the MTU discovery …\nSpecifies the MTU discovery config (see <code>MtuDiscoveryConfig</code> …\nConstruct an endpoint with arbitrary configuration and …\nCreate a default config with a particular <code>reset_key</code>\nCreate a default config with a particular handshake token …\nCreate a default config with a particular cryptographic …\nCreate a new StreamId\nConstruct a timer that will expire at <code>i</code>\nConstruct an endpoint with arbitrary configuration and …\nLook up the current time\nLook up the current time\nThe offset in the stream\nInitiate a new outgoing bidirectional stream.\nGet the number of connections that are currently open\nInitiate a new outgoing unidirectional stream.\nMaximum reordering in packet number space before FACK …\nCryptographic identity of the peer\nNumber of consecutive PTOs after which network is …\nCheck whether the timer has expired, and register to be …\nAttempts to read from the stream into buf.\nReceive UDP datagrams, or register to be woken if …\nCheck whether the associated socket is likely to be …\nAttempt to write bytes from buf into the stream.\nThe preferred IPv4 address that will be communicated to …\nThe preferred IPv6 address that will be communicated to …\nGet the priority of the send stream\nRead data contiguously from the stream.\nRead the next segment of data\nRead the next segments of data\nReceive an application datagram\nRead an exact number of bytes contiguously from the stream.\nConvenience method to read all remaining data into a buffer\nHuman-readable reason for the close\nHuman-readable reason for the close\nSwitch to a new UDP socket\nSwitch to a new UDP socket\nMaximum number of bytes the peer may transmit across all …\nCompletes when the stream has been reset by the peer or …\nReject this incoming connection attempt\nThe peer’s UDP address.\nThe peer’s UDP address\nThe peer’s UDP address\nWhether the socket address that is initiating this …\nThe reordering threshold we will request the peer to use\nUpdate the timer to expire at <code>i</code>\nClose the send stream immediately.\nPrivate key used to send authenticated connection resets …\nRespond with a retry packet, requiring the client to retry …\nDuration after a stateless retry token was issued for …\nCurrent best estimate of this connection’s latency …\nThe segment size if this transmission contains multiple …\nTransmit <code>data</code> as an unreliable, unordered application …\nTransmit <code>data</code> as an unreliable, unordered application …\nMaximum number of bytes to transmit to a peer without …\nSet the client configuration used by <code>connect</code>\nModify the number of remotely initiated bidirectional …\nModify the number of remotely initiated unidirectional …\nSet the priority of the send stream\nSee <code>proto::TransportConfig::receive_window()</code>\nReplace the server configuration, affecting new incoming …\nAmount of data written to the caller-supplied buffer\nDrive <code>future</code> to completion in the background\nOptional source IP address for the datagram\nA stable identifier for this connection\nReturns connection statistics\nStop accepting data\nCompletes when the stream is stopped or read to completion …\nMaximum number of bytes the peer may transmit without …\nOverride supported QUIC versions\nMaximum reordering in time space before time based loss …\nPrivate key used to authenticate data included in …\nTransport configuration to use for incoming connections\nSet a custom <code>TransportConfig</code>\nSet a custom <code>TransportConfig</code>\nSucceeds iff <code>x</code> &lt; 2^62\nSucceeds iff <code>x</code> &lt; 2^62\nSucceeds iff <code>x</code> &lt; 2^62\nSend UDP datagrams from <code>transmits</code>, or return <code>WouldBlock</code> …\nSpecifies the upper bound to the max UDP payload size that …\nSet the QUIC version to use\nWait for all connections on the endpoint to be cleanly …\nCreate a server config with the given <code>crypto::ServerConfig</code>\nCreate a client configuration that trusts specified trust …\nCreate a server config with the given certificate chain to …\nConvert <code>t</code> into the socket type used by this runtime\nWrite bytes to the stream\nConvenience method to write an entire buffer to the stream\nConvenience method to write an entire list of chunks to …\nConvenience method to write a single chunk in its entirety …\nWrite chunks to the stream\nExperimental! Use at your own risk.\nConfiguration for the <code>Bbr</code> congestion controller\nCommon interface for different congestion controllers\nConstructs controllers on demand\nThe RFC8312 congestion controller, as widely used for TCP\nConfiguration for the <code>Cubic</code> congestion controller\nA simple, standard congestion controller\nConfiguration for the <code>NewReno</code> congestion controller\nConstruct a fresh <code>Controller</code>\nDuplicate the controller’s state\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitial congestion window\nDefault limit on the amount of outstanding data in bytes.\nDefault limit on the amount of outstanding data in bytes.\nDefault limit on the amount of outstanding data in bytes.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns Self for use in down-casting to extract …\nReduction in congestion window when a new loss event is …\nConstruct a state using the given <code>config</code> and current time …\nConstruct a state using the given <code>config</code> and current time …\nConstruct a state using the given <code>config</code> and current time …\nPacket deliveries were confirmed\nPackets were deemed lost or marked congested\nPackets are acked in batches, all with the same <code>now</code> …\nThe known MTU for the current network path has been updated\nOne or more packets were just sent\nNumber of ack-eliciting bytes that may be in flight\nA key for sealing data with AEAD-based algorithms\nClient-side configuration for the crypto protocol\nGeneric crypto errors\nError returned by Session::export_keying_material.\nA pseudo random key for HKDF\nKeys used to protect packet headers\nA key for signing with HMAC-based algorithms\nA pair of keys for bidirectional communication\nA complete set of keys for a certain packet space\nKeys used to protect packet payloads\nServer-side configuration for the crypto protocol\nA cryptographic session (commonly TLS)\nError indicating that the specified QUIC version is not …\nDerive AEAD using hkdf\nMaximum number of packets that may be sent using a single …\nDecrypt the packet payload with the given packet number\nDecrypt the given packet’s header\nGet the 0-RTT keys if available (clients only)\nIf the 0-RTT-encrypted data has been accepted by the peer\nEncrypt the packet payload with the given packet number\nEncrypt the given packet’s header\nFill <code>output</code> with <code>output.len()</code> bytes of keying material …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet data negotiated during the handshake, if available\nHeader protection keys\nCreate the initial set of keys given the client’s …\nCreate the initial set of keys given the client’s …\nMaximum number of incoming packets that may fail …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> until the connection is fully established.\nVerify the integrity of a retry packet\nKey for encrypting data\nCompute keys for the next key update\nMethod for opening a sealed message <code>data</code>\nPacket protection keys\nGet the peer’s identity, if available\nRead bytes of handshake data\nKey for decrypting data\nGenerate the integrity tag for a retry packet\nTLS interface based on rustls\nThe sample size used for this key’s algorithm\nMethod for sealing message <code>data</code>\nMethod for signing a message\nLength of <code>sign</code>’s output\nStart a client session with this configuration\nStart a server session with this configuration\nThe length of the AEAD tag appended to packets on …\nThe peer’s QUIC transport parameters\nMethod for verifying a message\nWrites handshake bytes into the given buffer and …\nWe received a fatal alert.  This means the peer is unhappy.\nThe <code>max_fragment_size</code> value supplied in configuration was …\nWe couldn’t decrypt a message.  This is invariably fatal.\nWe couldn’t encrypt a message because it was larger than …\nrustls reports protocol errors using this type.\nWe failed to figure out what time it currently is.\nWe failed to acquire random bytes from the system.\nA catch-all error for unlikely errors.\nAuthentication data for (rustls) TLS session\nThis function doesn’t work until the TLS handshake is …\nWe received a TLS handshake message that isn’t valid …\nWe received a TLS message that isn’t valid right now. …\nA provided certificate revocation list (CRL) was invalid.\nWe saw an invalid certificate.\nThe peer sent us a TLS message with invalid contents.\nAn incoming connection did not support any known …\nThe peer didn’t give us any certificates.\nThe initial cipher suite (AES-128-GCM-SHA256) is not …\nAny other error.\nThe peer doesn’t support a protocol version/feature we …\nThe peer deviated from the standard TLS protocol. The …\nThe peer sent an oversized record/fragment.\nA QUIC-compatible TLS client configuration\nA QUIC-compatible TLS server configuration\nA rustls TLS session\nThe certificate verifier doesn’t support the given type …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFor the rustls <code>TlsSession</code>, the <code>Any</code> type is …\nThe negotiated application protocol, if ALPN is in use\nThe server name specified by the client, if any\nInitialize a QUIC-compatible TLS client configuration with …\nInitialize a QUIC-compatible TLS client configuration with …\nWhich types we expected\nWhich handshake type we expected\nWhat type we received\nWhat handshake type we received")