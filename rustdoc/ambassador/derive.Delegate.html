<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Delegate the implementation of a trait to a struct field/enum variants by adding `#[derive(Delegate)]` and its associated attribute `#[delegate(Trait)]` to it:"><title>Delegate in ambassador - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="ambassador" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.0 (051478957 2024-07-21)" data-channel="1.80.0" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc derive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../ambassador/index.html">ambassador</a><span class="version">0.4.1</span></h2></div><div class="sidebar-elems"></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Derive Macro <a href="index.html">ambassador</a>::<wbr><a class="derive" href="#">Delegate</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/ambassador/lib.rs.html#355-357">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>#[derive(Delegate)]
{
    <span class="comment">// Attributes available to this derive:</span>
    #[delegate]
}
</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Delegate the implementation of a trait to a struct field/enum variants by adding <code>#[derive(Delegate)]</code> and its associated attribute <code>#[delegate(Trait)]</code> to it:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ambassador::{Delegate, delegatable_trait};

<span class="attr">#[delegatable_trait]
</span><span class="kw">pub trait </span>Shout {
    <span class="kw">fn </span>shout(<span class="kw-2">&amp;</span><span class="self">self</span>, input: <span class="kw-2">&amp;</span>str) -&gt; String;
}

<span class="kw">pub struct </span>Cat;

<span class="kw">impl </span>Shout <span class="kw">for </span>Cat {
    <span class="kw">fn </span>shout(<span class="kw-2">&amp;</span><span class="self">self</span>, input: <span class="kw-2">&amp;</span>str) -&gt; String {
        <span class="macro">format!</span>(<span class="string">"{} - meow!"</span>, input)
    }
}

<span class="attr">#[derive(Delegate)] </span><span class="comment">// &lt;-------
</span><span class="attr">#[delegate(Shout)] </span><span class="comment">// &lt;-------- Delegate implementation of Shout to struct field
</span><span class="kw">pub struct </span>WrappedCat(Cat);</code></pre></div>
<h5 id="delegate-target--foo---target-key"><a class="doc-anchor" href="#delegate-target--foo---target-key">§</a><code>#[delegate(..., target = &quot;foo&quot;)]</code> - <code>target</code> key</h5>
<p>For structs with multiple fields, the field that should act as delegation target can be specified via the <code>target</code> key:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="attr">#[derive(Delegate)]
#[delegate(Shout, target = <span class="string">"foo"</span>)] </span><span class="comment">// &lt;-------- Delegate implementation of Shout to struct field .foo
</span><span class="kw">pub struct </span>WrappedCats {
  foo: Cat,
  bar: Cat,
}</code></pre></div>
<p>This also works for tuple structs with multiple fields, by using their index as a target key:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="attr">#[derive(Delegate)]
#[delegate(Shout, target = <span class="string">"1"</span>)] </span><span class="comment">// &lt;-------- Delegate implementation of Shout to second field
</span><span class="kw">pub struct </span>WrappedCats(Cat, Cat);</code></pre></div>
<h5 id="delegate-target--self---targetself"><a class="doc-anchor" href="#delegate-target--self---targetself">§</a><code>#[delegate(..., target = &quot;self&quot;)]</code> - <code>target=&quot;self&quot;</code></h5>
<p>Types that implement all the methods of a trait without implementing the trait itself,
can be made to implement that trait by setting <code>target=&quot;self&quot;</code>.
This doesn’t work for traits with associated types and constants, and requires the where clause to be added explicitly (see <code>where</code> key).
If the type doesn’t actually implement the methods (possibly due to an incomplete <code>where</code> clause) this can cause a <code>[unconditional_recursion]</code> error.</p>
<p>A possible use case of this is when refactoring some methods of a public type into a trait,
the type still needs to implement the methods outside the trait for semver reasons,
and using this feature reduces the boilderplate of implementing the trait with the same methods.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Delegate)]
#[delegate(Shout, target=<span class="string">"self"</span>)]
</span><span class="kw">pub struct </span>Cat;

<span class="kw">impl </span>Cat {
    <span class="kw">fn </span>shout(<span class="kw-2">&amp;</span><span class="self">self</span>, input: <span class="kw-2">&amp;</span>str) -&gt; String {
        <span class="macro">format!</span>(<span class="string">"{} - meow!"</span>, input)
    }
}</code></pre></div>
<h5 id="delegate-where--a-debug---where-key"><a class="doc-anchor" href="#delegate-where--a-debug---where-key">§</a><code>#[delegate(..., where = &quot;A: Debug&quot;)]</code> - <code>where</code> key</h5>
<p>To make a delegation apply only for certain generic bounds, similar to a <a href="https://doc.rust-lang.org/stable/rust-by-example/generics/where.html">native where clause</a>, you can specify a <code>where</code> attribute:</p>
<p>A where clause is automatically applied that makes sure the target field implements the trait being delegated</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fmt::Debug;

<span class="attr">#[derive(Delegate)]
#[delegate(Shout, <span class="kw">where </span>= <span class="string">"A: Debug"</span>)] </span><span class="comment">// &lt;---- Delegate implementation of Shout to .foo field if foo field implements Debug
// "A: Shout" is automatically added
</span><span class="kw">pub struct </span>WrappedFoo&lt;A&gt; {
  foo: A,
}</code></pre></div>
<h5 id="delegateshoutx-generics--x---trait-generics"><a class="doc-anchor" href="#delegateshoutx-generics--x---trait-generics">§</a><code>#[delegate(Shout&lt;X&gt;, generics = &quot;X&quot;)]</code> - trait generics</h5>
<p>We can also delegate traits with generics.
The type parameters listed in the <code>generics</code> key are treated as fully generic.
The automatically added where clause ensures they are valid for the inner type being delegated to.
Explict where clauses to further refine these types can be added as normal.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ambassador::{delegatable_trait, Delegate};
<span class="kw">use </span>std::fmt::Display;

<span class="attr">#[delegatable_trait]
</span><span class="kw">pub trait </span>Shout&lt;T&gt; {
    <span class="kw">fn </span>shout(<span class="kw-2">&amp;</span><span class="self">self</span>, input: T) -&gt; String;
}

<span class="kw">pub struct </span>Cat;

<span class="kw">impl</span>&lt;T: Display&gt; Shout&lt;T&gt; <span class="kw">for </span>Cat {
    <span class="kw">fn </span>shout(<span class="kw-2">&amp;</span><span class="self">self</span>, input: T) -&gt; String {
        <span class="macro">format!</span>(<span class="string">"{} - meow!"</span>, input)
    }
}

<span class="attr">#[derive(Delegate)]
#[delegate(Shout&lt;X&gt;, generics = <span class="string">"X"</span>)] </span><span class="comment">// &lt;-------- `X` is fully generic
// The automatic where clause ensures X: Display
// We could also use #[delegate(Shout&lt;&amp; 'a str&gt;, generics = "'a")] to only delegate for &amp;str
</span><span class="kw">pub struct </span>WrappedCat(Cat);</code></pre></div>
<h5 id="delegateshout-automatic_where_clause--false---inhibit-automatic-generation-of-where-clause"><a class="doc-anchor" href="#delegateshout-automatic_where_clause--false---inhibit-automatic-generation-of-where-clause">§</a><code>#[delegate(Shout, automatic_where_clause = &quot;false&quot;)]</code> - inhibit automatic generation of <code>where</code> clause.</h5>
<p>Normally <code>#[derive(Delegate)]</code> generates code to ensure that chosen field
indeed implements the trait you want to implement for the container struct.</p>
<p>For example, the <code>#[derive(Delegate)]</code> + <code>#[delegate(Shout&lt;X&gt;, generics = &quot;X&quot;)]</code>
in the example above will emit code that requires <code>Cat</code> (the type we’re
delegating to) to implement <code>Shout&lt;X&gt;</code>: <code>Cat: Shout&lt;X&gt;</code>.</p>
<p>However, you may want to delegate implementation to a type that does not in
fact fully implement the trait in question but instead has <em>compatible
methods</em> that can be called as if the trait were in fact implemented.</p>
<p>One notable examples of this is delegating a trait implementation to
container types holding a trait object; i.e. <code>MyTrait</code> for
<code>Box&lt;dyn MyTrait&gt;</code>. In this example, <code>Box&lt;dyn MyTrait</code>
<a href="https://doc.rust-lang.org/1.80.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref"><code>Deref</code></a>s into <code>dyn MyTrait</code> which provides <code>MyTrait</code>s
methods; this allows us effectively just call <code>MyTrait</code>s methods directly
on <code>Box&lt;dyn MyTrait&gt;</code> even though <code>Box&lt;dyn MyTrait&gt;</code> does not actually
implement <code>MyTrait</code>.</p>
<p><code>automatic_where_clause = &quot;false&quot;</code> lets us create a delegated impl of
<code>MyTrait</code> that takes advantage of this.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ambassador::{delegatable_trait, Delegate};
<span class="kw">use </span>std::fmt::Display;

<span class="attr">#[delegatable_trait]
</span><span class="kw">pub trait </span>Shout {
    <span class="kw">fn </span>shout(<span class="kw-2">&amp;</span><span class="self">self</span>, input: <span class="kw-2">&amp;</span>str) -&gt; String;
}

<span class="kw">pub struct </span>Cat;

<span class="kw">impl </span>Shout <span class="kw">for </span>Cat {
    <span class="kw">fn </span>shout(<span class="kw-2">&amp;</span><span class="self">self</span>, input: <span class="kw-2">&amp;</span>str) -&gt; String {
        <span class="macro">format!</span>(<span class="string">"{} - meow!"</span>, input)
    }
}

<span class="attr">#[derive(Delegate)]
#[delegate(Shout, automatic_where_clause = <span class="string">"false"</span>)]
</span><span class="kw">pub struct </span>BoxedAnimal(<span class="kw">pub </span>Box&lt;<span class="kw">dyn </span>Shout + Send + Sync&gt;);

<span class="comment">// Can accept both `Cat` and `BoxedAnimal`.
</span><span class="kw">fn </span>recording_studio&lt;S: Shout&gt;(voice_actor: S){}</code></pre></div>
<p>Note that it is also possible to create such a delegated impl by making use
of <a href="attr.delegate_to_remote_methods.html" title="attr ambassador::delegate_to_remote_methods"><code>delegate_to_remote_methods</code></a> with <a href="https://doc.rust-lang.org/1.80.0/core/ops/deref/trait.Deref.html#tymethod.deref" title="method core::ops::deref::Deref::deref"><code>Deref::deref</code></a> and
<a href="https://doc.rust-lang.org/1.80.0/core/ops/deref/trait.DerefMut.html#tymethod.deref_mut" title="method core::ops::deref::DerefMut::deref_mut"><code>DerefMut::deref_mut</code></a> as the target methods. The docs on
<a href="attr.delegate_to_remote_methods.html" title="attr ambassador::delegate_to_remote_methods"><code>delegate_to_remote_methods</code></a> contain an example of this.</p>
</div></details></section></div></main></body></html>