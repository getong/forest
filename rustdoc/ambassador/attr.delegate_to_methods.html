<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Delegate the implementation of a trait to a type’s methods by adding `#[delegate_to_methods]` and its associated attribute `#[delegate(Trait)]` to the relevant impl block"><title>delegate_to_methods in ambassador - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="ambassador" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.0 (051478957 2024-07-21)" data-channel="1.80.0" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc attr"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../ambassador/index.html">ambassador</a><span class="version">0.4.1</span></h2></div><div class="sidebar-elems"></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Attribute Macro <a href="index.html">ambassador</a>::<wbr><a class="attr" href="#">delegate_to_methods</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/ambassador/lib.rs.html#533-535">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>#[delegate_to_methods]</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Delegate the implementation of a trait to a type’s methods by adding <code>#[delegate_to_methods]</code> and its associated attribute <code>#[delegate(Trait)]</code> to the relevant impl block</p>
<h5 id="delegate-target_owned--foo-target_ref--bar-target_mut--baz---target-keys"><a class="doc-anchor" href="#delegate-target_owned--foo-target_ref--bar-target_mut--baz---target-keys">§</a><code>#[delegate(..., target_owned = &quot;foo&quot;, target_ref = &quot;bar&quot;, target_mut = &quot;baz&quot;)]</code> - <code>target</code> keys</h5>
<p>Three different target methods can be specified depending on the receiver of of the trait method being delegated.
These methods must have the signatures target_owned: “fn foo(self) -&gt; X”, target_ref: “fn bar(&amp;self) -&gt; &amp;X”, and target_mut: “fn baz(&amp;mut self) -&gt; &amp;mut X”
where X is the same type for all three.
Excluding some of these attributes is allowed as long as the trait being delegated to doesn’t have any methods with the relevant receiver
Additional methods that don’t have any of the relevant signature types may be included in the impl block as long as they are never used as targets.</p>
<h5 id="the-where-and-generics-keys-described-in-delegate-are-also-supported-and-function-the-same-way"><a class="doc-anchor" href="#the-where-and-generics-keys-described-in-delegate-are-also-supported-and-function-the-same-way">§</a>The <code>where</code> and <code>generics</code> keys described in <a href="derive.Delegate.html" title="derive ambassador::Delegate"><code>Delegate</code></a> are also supported and function the same way</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::ops::{Deref, DerefMut};
<span class="kw">use </span>ambassador::{delegate_to_methods, delegatable_trait};

<span class="attr">#[delegatable_trait]
</span><span class="kw">pub trait </span>Shout {
    <span class="kw">fn </span>shout(<span class="kw-2">&amp;</span><span class="self">self</span>, input: <span class="kw-2">&amp;</span>str) -&gt; String;
}

<span class="kw">pub struct </span>Cat;

<span class="kw">impl </span>Shout <span class="kw">for </span>Cat {
    <span class="kw">fn </span>shout(<span class="kw-2">&amp;</span><span class="self">self</span>, input: <span class="kw-2">&amp;</span>str) -&gt; String {
        <span class="macro">format!</span>(<span class="string">"{} - meow!"</span>, input)
    }
}

<span class="kw">pub struct </span>BoxedCat(Box&lt;Cat&gt;); <span class="comment">// Target is hidden behind a box

</span><span class="attr">#[delegate_to_methods]
#[delegate(Shout, target_ref = <span class="string">"inner"</span>, target_mut = <span class="string">"inner_mut"</span>)]
</span><span class="kw">impl </span>BoxedCat {
   <span class="kw">fn </span>inner(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>Cat {
        <span class="self">self</span>.<span class="number">0</span>.deref()
    }

    <span class="comment">// Note we don't need target_mut = "inner_mut" in this case but it is included as an example
    // The return type must be &amp;mut Cat to match inner's return type &amp;Cat
    </span><span class="kw">fn </span>inner_mut(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;mut </span>Cat {
        <span class="self">self</span>.<span class="number">0</span>.deref_mut()
    }

    <span class="comment">// You can also have extra methods here:
    </span><span class="kw">fn </span>another_one(<span class="kw-2">&amp;</span><span class="self">self</span>) { }
}</code></pre></div>
<h5 id="delegate_to_methods-on-an-impl-trait-for--block"><a class="doc-anchor" href="#delegate_to_methods-on-an-impl-trait-for--block">§</a><code>delegate_to_methods</code> on an <code>impl Trait for ...</code> block</h5>
<p>It’s also valid to use <code>delegate_to_methods</code> with a trait impl; i.e. to use
the methods from a different trait to delegate a trait. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">pub struct </span>RefCat&lt;<span class="lifetime">'a</span>&gt;(<span class="kw-2">&amp;</span><span class="lifetime">'a </span>Cat);

<span class="attr">#[delegate_to_methods]
#[delegate(Shout, target_ref = <span class="string">"deref"</span>)]
</span><span class="kw">impl</span>&lt;<span class="lifetime">'a</span>&gt; Deref <span class="kw">for </span>RefCat&lt;<span class="lifetime">'a</span>&gt; {
    <span class="kw">type </span>Target = Cat;

    <span class="kw">fn </span>deref(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>Cat { <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="number">0 </span>}
}</code></pre></div>
<p>Note that this has a caveat: if the target methods you are delegating to
share the same name as any of the methods in the trait being delegated you
will likely get errors about ambiguity. For example:</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code>
<span class="kw">pub struct </span>RefCat&lt;<span class="lifetime">'a</span>&gt;(<span class="kw-2">&amp;</span><span class="lifetime">'a </span>Cat);

<span class="kw">trait </span>GetAShouter {
  <span class="kw">type </span>Shouter: Shout;

  <span class="kw">fn </span>shout(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="self">Self</span>::Shouter;
}

<span class="attr">#[delegate_to_methods]
#[delegate(Shout, target_ref = <span class="string">"shout"</span>)]
</span><span class="kw">impl</span>&lt;<span class="lifetime">'a</span>&gt; GetAShouter <span class="kw">for </span>RefCat&lt;<span class="lifetime">'a</span>&gt; {
    <span class="kw">type </span>Shouter = Cat;

    <span class="kw">fn </span>shout(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>Cat { <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="number">0 </span>}
}</code></pre></div>
<p>Yields:</p>
<div class="example-wrap"><pre class="language-text"><code>error[E0034]: multiple applicable items in scope
  --&gt; src/lib.rs:363:32
   |
26 | #[delegate(Shout, target_ref = &quot;shout&quot;)]
   |                                ^^^^^^^ multiple `shout` found
   |
note: candidate #1 is defined in an impl of the trait `Shout` for the type `RefCat&lt;&#39;a&gt;`
  --&gt; src/lib.rs:345:5
   |
8  |     fn shout(&amp;self, input: &amp;str) -&gt; String;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
25 | #[delegate_to_methods]
   | ---------------------- in this procedural macro expansion
note: candidate #2 is defined in an impl of the trait `GetAShouter` for the type `RefCat&lt;&#39;a&gt;`
  --&gt; src/lib.rs:367:5
   |
30 |     fn shout(&amp;self) -&gt; &amp;Cat { &amp;self.0 }
   |     ^^^^^^^^^^^^^^^^^^^^^^^
   = note: this error originates in the macro `ambassador_impl_Shout` (in Nightly builds, run with -Z macro-backtrace for more info)
</code></pre></div>
<p>This is not an issue when the target methods are <em>inherent</em> since inherent
methods explicitly <a href="https://dtolnay.github.io/rust-quiz/23">have priority over trait methods</a>
during method resolution.</p>
<p>The workaround is to create wrapper inherent methods for the trait’s methods:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">pub struct </span>RefCat&lt;<span class="lifetime">'a</span>&gt;(<span class="kw-2">&amp;</span><span class="lifetime">'a </span>Cat);

<span class="kw">trait </span>GetAShouter {
  <span class="kw">type </span>Shouter: Shout;

  <span class="kw">fn </span>shout(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="self">Self</span>::Shouter;
}

<span class="kw">impl</span>&lt;<span class="lifetime">'a</span>&gt; GetAShouter <span class="kw">for </span>RefCat&lt;<span class="lifetime">'a</span>&gt; {
    <span class="kw">type </span>Shouter = Cat;

    <span class="kw">fn </span>shout(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>Cat { <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="number">0 </span>}
}

<span class="attr">#[delegate_to_methods]
#[delegate(Shout, target_ref = <span class="string">"get_a_shouter"</span>)]
</span><span class="kw">impl</span>&lt;<span class="lifetime">'a</span>&gt; RefCat&lt;<span class="lifetime">'a</span>&gt; { <span class="kw">fn </span>get_a_shouter(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>Cat { GetAShouter::shout(<span class="self">self</span>) } }</code></pre></div>
</div></details></section></div></main></body></html>